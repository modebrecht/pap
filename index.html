
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🧭 PAP Builder - v1.4</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --ink:#1f2937;
      --muted:#6b7280;
      --accent:#16a34a; /* green */
      --accent-2:#06b6d4; /* cyan */
      --panel:#46474A; /* anthracite */
      --panel-ink:#f1f5f9;
      --node:#ffffff;
      --node-stroke:#cbd5e1;
      --node-selected:#3b82f6;
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --grid-step:20px;
      --node-font-size:12px;
      --node-font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink); font-size:14px; line-height:1.4; font-family:var(--node-font-family);
      display:grid; grid-template-columns:240px minmax(0,1fr); grid-template-rows:auto minmax(0,1fr); grid-template-areas:
      "header header"
      "sidebar main";
    }
    header{grid-area:header; display:flex; align-items:center; gap:12px; padding:6px 14px; background:#fff; box-shadow:var(--shadow); position:sticky; top:0; z-index:2}
    header h1{font-size:16px; margin:0; font-weight:700; display:flex; align-items:center; gap:6px}
    header .spacer{flex:1}
    header button, header .file-btn-label{
      border:1px solid #d1d5db; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; transition:.15s ease; font-weight:600; display:flex; align-items:center; justify-content:center; line-height:1
    }
    header button:hover, header .file-btn-label:hover{background:#f3f4f6}
    header button:disabled{opacity:.5; cursor:not-allowed}
    header button:disabled:hover{background:#fff}
    header .project-title{
      flex:0 0 260px; max-width:320px; padding:8px 12px; border:1px solid #d1d5db; border-radius:10px; font:inherit; font-weight:600; background:#fff; transition:border-color .15s ease, box-shadow .15s ease;
    }
    header .project-title::placeholder{color:var(--muted)}
    header .project-title:focus{outline:none; border-color:#3b82f6; box-shadow:0 0 0 3px rgba(59,130,246,.2)}
    header .project-title.invalid{border-color:#dc2626; box-shadow:0 0 0 3px rgba(220,38,38,.15)}
    .emoji{font-size:1.6em; line-height:1}
    .btn-group{display:flex; align-items:stretch; gap:0}
    .btn-group > *{margin:0; display:flex; align-items:center; justify-content:center}
    .btn-group > .dropdown{display:flex; align-items:stretch}
    .btn-group > .dropdown > button{height:100%}
    .btn-group > button,
    .btn-group > .file-btn-label,
    .btn-group > .dropdown > button{border-radius:0; font-weight:inherit; font-size:inherit; text-transform:none}
    .btn-group > button:not(:first-child),
    .btn-group > .file-btn-label:not(:first-child),
    .btn-group > .dropdown:not(:first-child) > button{margin-left:-1px}
    .btn-group > button:first-child,
    .btn-group > .file-btn-label:first-child,
    .btn-group > .dropdown:first-child > button{border-top-left-radius:10px; border-bottom-left-radius:10px}
    .btn-group > button:last-child,
    .btn-group > .file-btn-label:last-child,
    .btn-group > .dropdown:last-child > button{border-top-right-radius:10px; border-bottom-right-radius:10px}
    header .file-input{display:none}

    /* Export dropdown */
    .dropdown{position:relative}
    .dropdown .menu{position:absolute; right:0; top:calc(100% + 6px); background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:var(--shadow); display:none; min-width:220px; overflow:hidden; z-index:5}
    .dropdown .menu.show{display:block}
    .dropdown .menu button{display:block; width:100%; padding:10px 12px; text-align:left; border:0; background:#fff; cursor:pointer; font-weight:600}
    .dropdown .menu button:hover{background:#f3f4f6}

    aside{grid-area:sidebar; background:var(--panel); color:var(--panel-ink); padding:12px; display:flex; flex-direction:column; gap:0px; box-shadow: inset -1px 0 0 rgba(255,255,255,.06); overflow:auto; min-height:0}
    .palette h2{margin:4px 0 8px; font-size:13px; text-transform:uppercase; letter-spacing:.08em; color:#d1d5db}
    .shape{background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.2); border-radius:12px; padding:10px; display:flex; align-items:center; gap:10px; cursor:grab; user-select:none}
    .shape + .shape{margin-top:10px}
    .shape svg{width:36px; height:28px}
    .shape strong{color:#fff}
    .shape[draggable="true"]:active{cursor:grabbing}

    main{grid-area:main; position:relative; overflow-y:auto; overflow-x:hidden; min-width:0; min-height:0}
    body.horizontal-unlimited main{overflow-x:auto}
    #stage-wrap{position:relative; min-height:100%; min-width:100%; width:100%; height:100%}

    /* SVG canvas + grid */
    #canvas{display:block; background:
      linear-gradient(transparent calc(var(--grid-step) - 1px), #e5e7eb calc(var(--grid-step))),
      linear-gradient(90deg, transparent calc(var(--grid-step) - 1px), #e5e7eb calc(var(--grid-step)));
      background-size:var(--grid-step) var(--grid-step); background-position:0 0;
    }

    .node-base{filter:drop-shadow(0 2px 6px rgba(0,0,0,.08))}
    .node-shape{fill:var(--node); stroke:var(--node-stroke); stroke-width:2}
    .node.selected .node-shape{stroke:var(--node-selected); stroke-width:2.5}
    .node text{font:600 var(--node-font-size)/1.2 var(--node-font-family); fill:#111827; pointer-events:none}

    .connector{stroke:#64748b; stroke-width:2.25; stroke-linecap:round; pointer-events:stroke; cursor:pointer; transition:stroke-width .12s ease, stroke-opacity .12s ease}
    .connector.selected{stroke:var(--node-selected)}
    .connector.hover{stroke-width:4; stroke-opacity:.8}

    .badge{position:absolute; top:10px; left:10px; background:#111827; color:#e5e7eb; font-size:11px; padding:4px 8px; border-radius:999px; opacity:.85}

    .toast{position:fixed; right:12px; bottom:12px; background:#111827; color:#e5e7eb; padding:10px 12px; border-radius:12px; font-weight:600; opacity:0; transform:translateY(8px); transition:.2s ease}
    .toast.show{opacity:1; transform:translateY(0)}

    /* Settings modal */
    .modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:50}
    .modal-backdrop.show{display:flex}
    .modal{background:#fff; width:min(520px, calc(100% - 32px)); border-radius:14px; box-shadow:var(--shadow); padding:16px}
    .modal-head{display:flex; align-items:center; gap:12px; justify-content:space-between; margin-bottom:6px}
    .modal-head h3{margin:0; font-size:16px}
    .modal-head button{border:1px solid #d1d5db; background:#fff; padding:6px 8px; border-radius:10px; cursor:pointer}
    .modal-head button:hover{background:#f3f4f6}
    .modal .row{display:flex; align-items:center; justify-content:space-between; gap:16px; padding:10px 0; border-top:1px solid #e5e7eb}
    .modal .row:first-of-type{border-top:none}
    .modal-tip{margin-top:12px; padding-top:10px; border-top:1px solid #e5e7eb; font-size:12px; color:var(--muted); line-height:1.4}
    .modal-tip strong{display:block; color:var(--ink); margin-bottom:4px}
    .switch{position:relative; width:48px; height:28px; flex:0 0 auto}
    .switch input{display:none}
    .switch .track{position:absolute; inset:0; background:#e5e7eb; border-radius:999px; transition:.2s}
    .switch .thumb{position:absolute; top:3px; left:3px; width:22px; height:22px; border-radius:50%; background:#fff; box-shadow:0 1px 3px rgba(0,0,0,.25); transition:.2s}
    .switch input:checked + .track{background:#3b82f6}
    .switch input:checked ~ .thumb{left:23px}
    .palette{margin-bottom:18px}
    .palette-head{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px; touch-action:none}
    .palette-head h2{margin:0; flex:1}
    .palette-head .palette-controls{display:flex; align-items:center; gap:6px}
    .palette-head button{border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.12); color:#f8fafc; border-radius:8px; padding:4px 8px; font-weight:700; cursor:pointer; transition:.15s ease}
    .palette-head button:hover{background:rgba(255,255,255,.24)}
    .palette-head .btn-group button{border-radius:0}
    .palette-head .btn-group button:first-child{border-top-left-radius:8px; border-bottom-left-radius:8px}
    .palette-head .btn-group button:last-child{border-top-right-radius:8px; border-bottom-right-radius:8px}
    .arrows-hidden .connector{marker-end:none !important}
    .context-menu{position:fixed; display:none; min-width:160px; background:#111827; color:#f8fafc; border-radius:10px; padding:6px 0; box-shadow:0 8px 24px rgba(15,23,42,.25); z-index:100; font-size:13px}
    .context-menu button{width:100%; padding:8px 14px; background:none; border:none; color:inherit; text-align:left; cursor:pointer}
    .context-menu button:hover{background:rgba(255,255,255,.1)}
    .floating-palette{position:fixed; top:120px; left:120px; width:208px; max-width:90vw; max-height:70vh; overflow:auto; background:var(--panel); color:var(--panel-ink); border-radius:16px; box-shadow:var(--shadow); padding:14px; display:none; z-index:80}
    .floating-palette.show{display:block}
    .floating-palette .palette{margin:0}
    .floating-palette .palette-head{cursor:move; user-select:none}
    .floating-palette .palette-head button{cursor:pointer}
    body.sidebar-collapsed{grid-template-columns:0 minmax(0,1fr)}
    body.sidebar-collapsed aside{display:none}
  </style>
</head>
<body>
  <header>
    <h1><span class="emoji">🧭</span>PAP&nbsp;Builder</h1>
    <input id="projectTitle" class="project-title" type="text" placeholder="Projektname eingeben..." aria-label="Projektname" required />
    <div class="spacer"></div>
    <div class="btn-group" id="groupImportExport">
      <button type="button" id="btnNew" title="Neues Projekt starten"><span class="emoji">🆕</span> Neu</button>
      <button type="button" id="btnImport" class="file-btn-label" title="Projekt aus JSON laden"><span class="emoji">📥</span> Import</button>
      <div class="dropdown" id="exportDropdown">
        <button id="btnExport" title="Export"><span class="emoji">📤</span> Export</button>
        <div class="menu" id="menuExport" role="menu" aria-hidden="true">
          <button type="button" data-action="export-json">Export JSON</button>
          <button type="button" data-action="export-png">Export PNG</button>
          <button type="button" data-action="export-png-grid">Export PNG + Linien</button>
        </div>
      </div>
    </div>
    <button id="btnSettings" title="Einstellungen"><span class="emoji">⚙️</span></button>
    <input id="fileImportJSON" class="file-input" type="file" accept="application/json" />
  </header>

  <aside>
    <div class="palette" id="paletteBausteine">
      <div class="palette-head" id="paletteBausteineHead">
        <h2>Bausteine</h2>
        <div class="palette-controls">
          <div class="btn-group" id="fontControls">
            <button type="button" id="btnFontIncrease" title="Schriftgroesse erhoehen">F+</button>
            <button type="button" id="btnFontDecrease" title="Schriftgroesse verringern">F-</button>
          </div>
          <button type="button" id="btnTogglePalette" aria-label="Palette einklappen">&laquo;</button>
        </div>
      </div>
      <div class="shape" draggable="true" data-shape="terminator" title="Start/Ende">
        <svg viewBox="0 0 100 60" aria-hidden="true"><rect x="5" y="10" width="90" height="40" rx="20" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Start/Ende</strong><div style="opacity:.8;font-size:12px">Terminator</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="process" title="Prozess">
        <svg viewBox="0 0 100 60" aria-hidden="true"><rect x="5" y="10" width="90" height="40" rx="8" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Prozess</strong><div style="opacity:.8;font-size:12px">Anweisung</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="decision" title="Entscheidung">
        <svg viewBox="0 0 100 60" aria-hidden="true"><polygon points="50,5 95,30 50,55 5,30" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Entscheidung</strong><div style="opacity:.8;font-size:12px">Ja/Nein</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="io" title="Ein-/Ausgabe">
        <svg viewBox="0 0 100 60" aria-hidden="true"><polygon points="20,10 95,10 80,50 5,50" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Ein-/Ausgabe</strong><div style="opacity:.8;font-size:12px">Parallelogramm</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="connector" title="Verbinder">
        <svg viewBox="0 0 100 60" aria-hidden="true"><circle cx="50" cy="30" r="16" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Verbinder</strong><div style="opacity:.8;font-size:12px">Kreis</div></div>
      </div>
    </div>
    <div class="palette" id="paletteActions">
      <h2>Aktionen</h2>
      <div style="font-size:13px; color:#e5e7eb; opacity:.9; line-height:1.5">
        • <b>Doppelklick</b> Baustein → umbenennen<br>
        • <b>Shift</b> + Klick zwei Formen → Pfeil verbinden<br>
        • <b>Entf</b> → Baustein löschen<br>
        • <b>Strg/⌘</b>+<b>D</b> → duplizieren
      </div>
    </div>
  </aside>

  <main>
    <div id="stage-wrap">
      <svg id="canvas" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <marker id="arrow" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto-start-reverse">
            <path d="M0,0 L8,3 L0,6 z" fill="#64748b"></path>
          </marker>
        </defs>
        <g id="connectors"></g>
        <g id="nodes"></g>
      </svg>
    </div>
  </main>
  <div class="floating-palette" id="floatingPalette" aria-hidden="true"></div>

  <div class="modal-backdrop" id="settingsModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="modal-head">
        <h3 id="settingsTitle">Einstellungen</h3>
        <button id="btnCloseSettings" aria-label="Schließen">✕</button>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Snap-to-grid</div>
          <div style="font-size:12px; color:var(--muted)">Rastergröße für das Platzieren und Verschieben von Formen</div>
        </div>
        <select id="selectGrid" style="padding:6px 8px; border-radius:10px; border:1px solid #d1d5db;">
          <option value="10">10px</option>
          <option value="20">20px (Standard)</option>
          <option value="30">30px</option>
          <option value="40">40px</option>
          <option value="50">50px</option>
          <option value="60">60px</option>
          <option value="70">70px</option>
          <option value="80">80px</option>
        </select>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Vertikal: unbegrenzt</div>
          <div style="font-size:12px; color:var(--muted)">Deaktivieren, um den Arbeitsbereich nach oben/unten zu begrenzen</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleVerticalUnlimited" checked>
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Horizontal: unbegrenzt</div>
          <div style="font-size:12px; color:var(--muted)">Aktivieren, um den Arbeitsbereich nach links/rechts freizugeben</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleHorizontalUnlimited">
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Pfeilspitzen anzeigen</div>
          <div style="font-size:12px; color:var(--muted)">Richtung der Verbindungen mit einer Pfeilspitze markieren</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleArrows" checked>
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Verbinder anzeigen</div>
          <div style="font-size:12px; color:var(--muted)">Für Einsteiger standardmäßig aus – später zuschalten</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleVerbinder">
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="modal-tip">
        <strong>Tipp:</strong> Doppelklick um Text zu &auml;ndern &middot; Shift&rarr; zwei Formen anklicken f&uuml;r Verbindung &middot; Entf zum L&ouml;schen
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="context-menu" id="connectorMenu" role="menu">
    <button type="button" id="connectorDelete">Verbindung l&ouml;schen</button>
    <button type="button" id="connectorToggleArrow">Pfeil ausblenden</button>
  </div>
  <div class="context-menu" id="nodeMenu" role="menu">
    <button type="button" id="nodeDelete">Baustein l&ouml;schen</button>
  </div>

  <script>
  // --- State ---
  const state = {
    nodes: new Map(),
    connectors: new Map(),
    selection: null,
    pendingLinkFrom: null,
    grid: 20,
    idCounter: 1,
    showVerbinder: false,
    verticalUnlimited: true,
    horizontalUnlimited: false,
    viewportWidth: 0,
    viewportHeight: 0,
    maxViewportWidth: 0,
    maxViewportHeight: 0,
    showArrows: true,
    fontSize: 12,
    sidebarCollapsed: false,
    title: '',
    palettePosition: {x:120, y:120},
    contextConnectorId: null,
    contextNodeId: null,
    dirty: false,
    tabId: null,
    restoredFromAutosave: false
  };

  const $ = (sel,root=document)=>root.querySelector(sel);
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
  const canvas = document.getElementById('canvas');
  const layerNodes = document.getElementById('nodes');
  const layerCons = document.getElementById('connectors');
  const toast = document.getElementById('toast');
  const stageWrap = document.getElementById('stage-wrap');
  const mainArea = document.querySelector('main');
  const fileImport = document.getElementById('fileImportJSON');
  const inputTitle = document.getElementById('projectTitle');
  const btnNew = document.getElementById('btnNew');
  const btnImport = document.getElementById('btnImport');
  const ARROW_PADDING = 0;
  const aside = document.querySelector('aside');
  const connectorMenu = document.getElementById('connectorMenu');
  const connectorToggleArrow = document.getElementById('connectorToggleArrow');
  const connectorDelete = document.getElementById('connectorDelete');
  let connectorMenuVisible = false;
  const nodeMenu = document.getElementById('nodeMenu');
  const nodeDelete = document.getElementById('nodeDelete');
  const btnFontIncrease = document.getElementById('btnFontIncrease');
  const btnFontDecrease = document.getElementById('btnFontDecrease');
  const paletteBausteine = document.getElementById('paletteBausteine');
  const paletteActions = document.getElementById('paletteActions');
  const floatingPalette = document.getElementById('floatingPalette');
  const paletteBausteineHead = document.getElementById('paletteBausteineHead');
  const btnTogglePalette = document.getElementById('btnTogglePalette');
  let nodeMenuVisible = false;
  let paletteDrag = null;
  const FONT_WEIGHT = 600;
  const FONT_FAMILY = 'system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif';
  const FONT_SIZE_MIN = 10;
  const FONT_SIZE_MAX = 26;
  const FONT_SIZE_STEP = 2;
  const LABEL_TEXT_PADDING = 24;
  const measureCanvas = document.createElement('canvas');
  const measureCtx = measureCanvas.getContext('2d');
  if(measureCtx){ measureCtx.font = `${FONT_WEIGHT} ${state.fontSize}px ${FONT_FAMILY}`; }

  // --- Autosave (per tab) ---
  function ensureTabId(){
    try{
      let id = sessionStorage.getItem('pap.tabId');
      if(!id){ id = (window.crypto?.randomUUID?.() || (Date.now().toString(36)+Math.random().toString(36).slice(2))); sessionStorage.setItem('pap.tabId', id); }
      return id;
    }catch{ return 'tab-'+Date.now().toString(36); }
  }
  state.tabId = ensureTabId();
  const autosaveKey = ()=>`pap.autosave.${state.tabId}`;
  const autosaveFallbackKey = 'pap.autosave.latest';
  const markDirty = ()=>{ state.dirty = true; };
  function saveAutosave(force=false){
    if(!force && !state.dirty) return;
    try{
      const json = serializeProject();
      localStorage.setItem(autosaveKey(), json);
      localStorage.setItem(autosaveFallbackKey, json);
      state.dirty = false;
    }catch(err){
      console.warn('Autosave konnte nicht gespeichert werden', err);
    }
  }
  function readAutosaveSnapshot(){
    const keys = [autosaveKey(), autosaveFallbackKey];
    for(const key of keys){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) continue;
        const data = JSON.parse(raw);
        if(isValidSnapshot(data)) return data;
        console.warn('Autosave verworfen (ungültiges Format)', key, data);
      }catch(err){
        console.warn('Autosave konnte nicht geladen werden', err);
      }
    }
    return null;
  }
  function restoreAutosaveIfAny(){
    const snapshot = readAutosaveSnapshot();
    if(!snapshot) return;
    loadFromData(snapshot);
    state.restoredFromAutosave = true;
    showToast('Autosave geladen');
  }
  setInterval(()=>saveAutosave(true), 30000);
  window.addEventListener('beforeunload', ()=>{ try{ saveAutosave(true); }catch{} });

  // Resize SVG viewBox to pixel size for easy math
  const resizeCanvas = () => {
    const rectSource = mainArea || canvas.parentElement || document.body;
    const rect = rectSource.getBoundingClientRect();
    const width = Math.max(1, Math.floor(rect.width));
    const height = Math.max(1, Math.floor(rect.height));
    state.viewportWidth = width;
    state.viewportHeight = height;
    state.maxViewportWidth = Math.max(state.maxViewportWidth || 0, width);
    state.maxViewportHeight = Math.max(state.maxViewportHeight || 0, height);
    requestStageSizeUpdate();
  };
  if(mainArea){
    new ResizeObserver(resizeCanvas).observe(mainArea);
  }else{
    new ResizeObserver(resizeCanvas).observe(document.body);
  }
  window.addEventListener('load', resizeCanvas);

  // Einstellungen (Modal) & Verbinder-Präferenz
  function loadSettings(){
    try{
      const raw = localStorage.getItem('pap.settings');
      if(!raw) return;
      const s = JSON.parse(raw);
      if(typeof s.showVerbinder==='boolean') state.showVerbinder = s.showVerbinder;
      const grid = Number(s.grid);
      if(Number.isFinite(grid) && grid > 0) state.grid = grid;
      if(typeof s.verticalUnlimited==='boolean') state.verticalUnlimited = s.verticalUnlimited;
      if(typeof s.horizontalUnlimited==='boolean') state.horizontalUnlimited = s.horizontalUnlimited;
      if(typeof s.showArrows==='boolean') state.showArrows = s.showArrows;
      const fontSize = Number(s.fontSize);
      if(Number.isFinite(fontSize)) state.fontSize = clampFontSize(fontSize);
      if(typeof s.sidebarCollapsed==='boolean') state.sidebarCollapsed = s.sidebarCollapsed;
      if(s.palettePosition) state.palettePosition = sanitizePalettePosition(s.palettePosition);
    }catch{}
  }
  function saveSettings(){
    try{
      localStorage.setItem('pap.settings', JSON.stringify({
        showVerbinder: state.showVerbinder,
        grid: state.grid,
        verticalUnlimited: state.verticalUnlimited,
        horizontalUnlimited: state.horizontalUnlimited,
        showArrows: state.showArrows,
        fontSize: state.fontSize,
        sidebarCollapsed: state.sidebarCollapsed,
        palettePosition: state.palettePosition
      }));
    }catch{}
  }
  const btnSettings = document.getElementById('btnSettings');
  const modal = document.getElementById('settingsModal');
  const closeBtn = document.getElementById('btnCloseSettings');
  const chkVerbinder = document.getElementById('toggleVerbinder');
  const verbinderTile = document.querySelector('.shape[data-shape="connector"]');
  const selectGrid = document.getElementById('selectGrid');
  const toggleVerticalUnlimited = document.getElementById('toggleVerticalUnlimited');
  const toggleHorizontalUnlimited = document.getElementById('toggleHorizontalUnlimited');
  const toggleArrows = document.getElementById('toggleArrows');

  function updateVerbinderUI(){
    if(verbinderTile) verbinderTile.style.display = state.showVerbinder ? '' : 'none';
    if(chkVerbinder) chkVerbinder.checked = !!state.showVerbinder;
  }
  function updateGridUI(){
    if(!selectGrid) return;
    const value = String(state.grid);
    let option = Array.from(selectGrid.options).find(opt=>opt.value===value);
    if(!option){
      option = document.createElement('option');
      option.value = value;
      option.textContent = `${value}px`;
      selectGrid.appendChild(option);
    }
    selectGrid.value = value;
  }
  function updateTitleValidity(){
    if(!inputTitle) return;
    const valid = state.title.trim().length > 0;
    inputTitle.classList.toggle('invalid', !valid);
  }
  function updateTitleInput(){
    if(!inputTitle) return;
    inputTitle.value = state.title;
    updateTitleValidity();
  }
  function applyOverflowModes(){
    document.body.classList.toggle('horizontal-unlimited', !!state.horizontalUnlimited);
  }
  function updateUnlimitedUI(){
    if(toggleVerticalUnlimited) toggleVerticalUnlimited.checked = !!state.verticalUnlimited;
    if(toggleHorizontalUnlimited) toggleHorizontalUnlimited.checked = !!state.horizontalUnlimited;
    applyOverflowModes();
  }
  function updateArrowsUI(){
    if(toggleArrows) toggleArrows.checked = !!state.showArrows;
  }
  function applyGridToCanvas(){
    document.documentElement.style.setProperty('--grid-step', `${state.grid}px`);
  }
  function applyArrowsToCanvas(){
    if(canvas){
      canvas.classList.toggle('arrows-hidden', !state.showArrows);
    }
  }
  function clampFontSize(value){
    return Math.max(FONT_SIZE_MIN, Math.min(FONT_SIZE_MAX, Math.round(value)));
  }
  function fontString(size){
    return `${FONT_WEIGHT} ${size}px ${FONT_FAMILY}`;
  }
  function lineHeightPx(size){
    return Math.round(size * 1.25);
  }
  function applyFontSize(){
    state.fontSize = clampFontSize(state.fontSize);
    document.documentElement.style.setProperty('--node-font-size', `${state.fontSize}px`);
    document.documentElement.style.setProperty('--node-font-family', FONT_FAMILY);
    if(measureCtx){ measureCtx.font = fontString(state.fontSize); }
    updateFontButtons();
  }
  function updateFontButtons(){
    if(btnFontIncrease) btnFontIncrease.disabled = state.fontSize >= FONT_SIZE_MAX;
    if(btnFontDecrease) btnFontDecrease.disabled = state.fontSize <= FONT_SIZE_MIN;
  }
  function measureLabelWidth(text){
    const str = String(text ?? '');
    if(!measureCtx) return str.length * 7;
    measureCtx.font = fontString(state.fontSize);
    return measureCtx.measureText(str).width;
  }
  function breakLongWord(word, maxWidth){
    const result=[];
    let current='';
    for(const char of String(word)){
      const attempt = current + char;
      if(current && measureLabelWidth(attempt) > maxWidth){
        result.push(current);
        current = char;
      }else{
        current = attempt;
      }
    }
    if(current) result.push(current);
    return result.length? result : [''];
  }
  function wrapLabelText(text, maxWidth){
    const raw = String(text ?? '').trim();
    if(!raw) return [''];
    const limit = Math.max(10, Number(maxWidth) || 0);
    const words = [];
    for(const token of raw.split(/\s+/)){
      if(!token) continue;
      if(measureLabelWidth(token) > limit){
        words.push(...breakLongWord(token, limit));
      }else{
        words.push(token);
      }
    }
    if(words.length === 0) return [''];
    const lines=[];
    let current = words.shift() || '';
    for(const word of words){
      const candidate = current ? `${current} ${word}` : word;
      if(measureLabelWidth(candidate) > limit && current){
        lines.push(current);
        current = word;
      }else{
        current = candidate;
      }
    }
    if(current) lines.push(current);
    return lines.length? lines : [''];
  }
  function sanitizePalettePosition(pos){
    const fallback = {x:120, y:120};
    if(!pos || typeof pos !== 'object') return {...fallback};
    const x = Number(pos.x);
    const y = Number(pos.y);
    return {
      x: Number.isFinite(x) ? x : fallback.x,
      y: Number.isFinite(y) ? y : fallback.y
    };
  }
  function applyPalettePosition(){
    if(!floatingPalette) return;
    const margin = 16;
    const width = floatingPalette.offsetWidth || 260;
    const height = floatingPalette.offsetHeight || 220;
    const sanitized = sanitizePalettePosition(state.palettePosition);
    let left = sanitized.x;
    let top = sanitized.y;
    const maxLeft = Math.max(margin, window.innerWidth - width - margin);
    const maxTop = Math.max(margin, window.innerHeight - height - margin);
    left = Math.min(maxLeft, Math.max(margin, left));
    top = Math.min(maxTop, Math.max(margin, top));
    floatingPalette.style.left = `${left}px`;
    floatingPalette.style.top = `${top}px`;
    state.palettePosition = {x:left, y:top};
  }
  function movePaletteToFloating(){
    if(!floatingPalette || !paletteBausteine) return;
    if(floatingPalette.contains(paletteBausteine)) return;
    floatingPalette.appendChild(paletteBausteine);
  }
  function movePaletteToSidebar(){
    if(!paletteBausteine || !aside) return;
    if(aside.contains(paletteBausteine)) return;
    if(paletteActions && aside.contains(paletteActions)) aside.insertBefore(paletteBausteine, paletteActions);
    else aside.appendChild(paletteBausteine);
  }
  function updateToggleButton(){
    if(!btnTogglePalette) return;
    const icon = state.sidebarCollapsed ? '\u00BB' : '\u00AB';
    btnTogglePalette.textContent = icon;
    const label = state.sidebarCollapsed ? 'Palette anheften' : 'Palette l\u00F6sen';
    btnTogglePalette.setAttribute('title', label);
    btnTogglePalette.setAttribute('aria-label', label);
    btnTogglePalette.setAttribute('aria-expanded', (!state.sidebarCollapsed).toString());
  }
  function setSidebarCollapsed(collapsed, {silent=false}={}){
    const next = !!collapsed;
    const previous = state.sidebarCollapsed;
    state.sidebarCollapsed = next;
    closeAllMenus();
    if(paletteDrag){
      const canReleaseDrag = floatingPalette && typeof floatingPalette.releasePointerCapture === 'function';
      if(paletteDrag.pointerId !== undefined && canReleaseDrag){
        try{ floatingPalette.releasePointerCapture(paletteDrag.pointerId); }catch{}
      }
      document.removeEventListener('pointermove', onPaletteDrag);
      document.removeEventListener('pointerup', stopPaletteDrag);
      paletteDrag = null;
    }
    if(next){
      document.body.classList.add('sidebar-collapsed');
      movePaletteToFloating();
      if(floatingPalette){
        floatingPalette.classList.add('show');
        floatingPalette.setAttribute('aria-hidden','false');
      }
      applyPalettePosition();
    }else{
      document.body.classList.remove('sidebar-collapsed');
      if(floatingPalette){
        floatingPalette.classList.remove('show');
        floatingPalette.setAttribute('aria-hidden','true');
      }
      movePaletteToSidebar();
    }
    updateToggleButton();
    requestStageSizeUpdate();
    if(!silent && previous !== next){
      saveSettings();
    }
  }
  function updatePalettePositionFromStyles(){
    if(!floatingPalette) return;
    const left = parseFloat(floatingPalette.style.left);
    const top = parseFloat(floatingPalette.style.top);
    if(Number.isFinite(left) && Number.isFinite(top)){
      state.palettePosition = {x:left, y:top};
    }
  }
  function startPaletteDrag(e){
    if(!state.sidebarCollapsed) return;
    if(!floatingPalette) return;
    if(typeof e.pointerType === 'string'){
      if(e.pointerType === 'mouse' && e.button !== 0) return;
    }else if(e.button !== undefined && e.button !== 0){
      return;
    }
    if(e.target.closest('button')) return;
    e.preventDefault();
    const rect = floatingPalette.getBoundingClientRect();
    paletteDrag = {
      offsetX: e.clientX - rect.left,
      offsetY: e.clientY - rect.top,
      pointerId: e.pointerId
    };
    if(typeof floatingPalette.setPointerCapture === 'function' && e.pointerId !== undefined){
      try{ floatingPalette.setPointerCapture(e.pointerId); }catch{}
    }
    document.addEventListener('pointermove', onPaletteDrag);
    document.addEventListener('pointerup', stopPaletteDrag);
    document.addEventListener('pointercancel', stopPaletteDrag);
  }
  function onPaletteDrag(e){
    if(!paletteDrag || !floatingPalette) return;
    const margin = 16;
    const width = floatingPalette.offsetWidth || 260;
    const height = floatingPalette.offsetHeight || 220;
    let left = e.clientX - paletteDrag.offsetX;
    let top = e.clientY - paletteDrag.offsetY;
    const maxLeft = Math.max(margin, window.innerWidth - width - margin);
    const maxTop = Math.max(margin, window.innerHeight - height - margin);
    left = Math.min(maxLeft, Math.max(margin, left));
    top = Math.min(maxTop, Math.max(margin, top));
    floatingPalette.style.left = `${left}px`;
    floatingPalette.style.top = `${top}px`;
  }
  function stopPaletteDrag(e){
    if(!paletteDrag) return;
    document.removeEventListener('pointermove', onPaletteDrag);
    document.removeEventListener('pointerup', stopPaletteDrag);
    document.removeEventListener('pointercancel', stopPaletteDrag);
    const canRelease = floatingPalette && typeof floatingPalette.releasePointerCapture === 'function';
    if(paletteDrag.pointerId !== undefined && canRelease){
      try{ floatingPalette.releasePointerCapture(paletteDrag.pointerId); }catch{}
    }
    updatePalettePositionFromStyles();
    paletteDrag = null;
    saveSettings();
  }
  function rerenderAllNodes(){
    for(const node of state.nodes.values()){
      renderNode(node);
    }
  }
  function setFontSize(size, silent=false){
    closeAllMenus();
    const clamped = clampFontSize(size);
    if(state.fontSize === clamped) return;
    state.fontSize = clamped;
    applyFontSize();
    rerenderAllNodes();
    saveSettings();
    markDirty();
    if(!silent) showToast(`Schriftgroesse: ${clamped}px`);
  }
  function adjustFontSize(delta){
    setFontSize(state.fontSize + delta);
  }
  function closeConnectorMenu(){
    if(connectorMenuVisible){
      connectorMenuVisible = false;
      state.contextConnectorId = null;
      if(connectorMenu) connectorMenu.style.display = 'none';
    }
  }
  function closeNodeMenu(){
    if(nodeMenuVisible){
      nodeMenuVisible = false;
      state.contextNodeId = null;
      if(nodeMenu) nodeMenu.style.display = 'none';
    }
  }
  function closeAllMenus(){
    closeConnectorMenu();
    closeNodeMenu();
  }
  function handleViewportChange(){
    closeAllMenus();
    applyPalettePosition();
  }
  function openConnectorMenu(connId, clientX, clientY){
    closeNodeMenu();
    const conn = state.connectors.get(connId);
    if(!conn){ closeConnectorMenu(); return; }
    state.contextConnectorId = connId;
    connectorMenuVisible = true;
    const hasArrow = connectorHasArrow(conn);
    if(connectorToggleArrow){
      connectorToggleArrow.textContent = hasArrow ? 'Pfeil ausblenden' : 'Pfeil anzeigen';
    }
    if(connectorMenu) connectorMenu.style.display = 'block';
    const menuRect = connectorMenu?.getBoundingClientRect() || {width:160,height:80};
    let left = clientX + 4;
    let top = clientY + 4;
    if(left + menuRect.width > window.innerWidth) left = window.innerWidth - menuRect.width - 8;
    if(top + menuRect.height > window.innerHeight) top = window.innerHeight - menuRect.height - 8;
    if(connectorMenu){
      connectorMenu.style.left = `${left}px`;
      connectorMenu.style.top = `${top}px`;
    }
  }
  function openNodeMenu(nodeId, clientX, clientY){
    closeConnectorMenu();
    if(!state.nodes.has(nodeId)){ closeNodeMenu(); return; }
    state.contextNodeId = nodeId;
    nodeMenuVisible = true;
    if(nodeMenu) nodeMenu.style.display = 'block';
    const menuRect = nodeMenu?.getBoundingClientRect() || {width:150,height:60};
    let left = clientX + 4;
    let top = clientY + 4;
    if(left + menuRect.width > window.innerWidth) left = window.innerWidth - menuRect.width - 8;
    if(top + menuRect.height > window.innerHeight) top = window.innerHeight - menuRect.height - 8;
    if(nodeMenu){
      nodeMenu.style.left = `${left}px`;
      nodeMenu.style.top = `${top}px`;
    }
  }
  const stageMargin = 200;
  let stageSizeRaf = 0;
  function computeNodeExtents(){
    if(state.nodes.size===0) return null;
    let maxX = 0;
    let maxY = 0;
    for(const node of state.nodes.values()){
      maxX = Math.max(maxX, node.x + node.w/2);
      maxY = Math.max(maxY, node.y + node.h/2);
    }
    return {maxX, maxY};
  }
  function updateStageSize(){
    if(!stageWrap || !canvas) return;
    const availableWidth = Math.max(1, Math.floor(mainArea?.clientWidth || stageWrap.clientWidth || state.viewportWidth || 1));
    const availableHeight = Math.max(1, Math.floor(mainArea?.clientHeight || stageWrap.clientHeight || state.viewportHeight || 1));
    const baseWidth = state.horizontalUnlimited
      ? Math.max(availableWidth, Math.floor(state.maxViewportWidth || 0))
      : availableWidth;
    const baseHeight = state.verticalUnlimited
      ? Math.max(availableHeight, Math.floor(state.maxViewportHeight || 0))
      : availableHeight;
    let targetWidth = baseWidth;
    let targetHeight = baseHeight;
    const extents = computeNodeExtents();
    if(extents){
      if(state.horizontalUnlimited){
        targetWidth = Math.max(targetWidth, Math.ceil(extents.maxX + stageMargin));
      }
      if(state.verticalUnlimited){
        targetHeight = Math.max(targetHeight, Math.ceil(extents.maxY + stageMargin));
      }
    }
    const w = Math.floor(targetWidth);
    const h = Math.floor(targetHeight);
    if(state.horizontalUnlimited){
      stageWrap.style.width = `${w}px`;
    }else{
      stageWrap.style.width = '';
    }
    if(state.verticalUnlimited){
      stageWrap.style.height = `${h}px`;
    }else{
      stageWrap.style.height = '';
    }
    canvas.setAttribute('viewBox', `0 0 ${w} ${h}`);
    canvas.setAttribute('width', w);
    canvas.setAttribute('height', h);
    if(state.horizontalUnlimited && targetWidth > (state.maxViewportWidth || 0)) state.maxViewportWidth = targetWidth;
    if(state.verticalUnlimited && targetHeight > (state.maxViewportHeight || 0)) state.maxViewportHeight = targetHeight;
    if(!state.verticalUnlimited || !state.horizontalUnlimited) enforceConstraintsForAllNodes();
  }
  function requestStageSizeUpdate(){
    if(stageSizeRaf) cancelAnimationFrame(stageSizeRaf);
    stageSizeRaf = requestAnimationFrame(()=>{
      stageSizeRaf = 0;
      updateStageSize();
    });
  }
  function setShowVerbinder(v){
    state.showVerbinder = !!v;
    updateVerbinderUI();
    saveSettings();
    showToast(state.showVerbinder ? 'Verbinder eingeblendet' : 'Verbinder ausgeblendet');
  }
  function setGridSize(value){
    const size = Number(value);
    if(!Number.isFinite(size) || size <= 0) return;
    if(state.grid === size){ updateGridUI(); return; }
    state.grid = size;
    applyGridToCanvas();
    updateGridUI();
    saveSettings();
    markDirty();
    showToast(`Snap-to-grid: ${size}px`);
  }
  function setVerticalUnlimited(v){
    state.verticalUnlimited = !!v;
    updateUnlimitedUI();
    saveSettings();
    markDirty();
    if(!state.verticalUnlimited){
      const viewportHeight = Math.max(1, state.viewportHeight || mainArea?.clientHeight || stageWrap.clientHeight || 1);
      state.maxViewportHeight = viewportHeight;
      enforceConstraintsForAllNodes();
    }
    requestStageSizeUpdate();
    showToast(state.verticalUnlimited ? 'Vertikale Begrenzung aus' : 'Vertikale Begrenzung an');
  }
  function setHorizontalUnlimited(v){
    state.horizontalUnlimited = !!v;
    updateUnlimitedUI();
    saveSettings();
    markDirty();
    if(!state.horizontalUnlimited){
      const viewportWidth = Math.max(1, state.viewportWidth || mainArea?.clientWidth || stageWrap.clientWidth || 1);
      state.maxViewportWidth = viewportWidth;
      enforceConstraintsForAllNodes();
    }
    requestStageSizeUpdate();
    showToast(state.horizontalUnlimited ? 'Horizontale Begrenzung aus' : 'Horizontale Begrenzung an');
  }
  function setShowArrows(v){
    const next = !!v;
    if(state.showArrows === next){
      updateArrowsUI();
      return;
    }
    state.showArrows = next;
    updateArrowsUI();
    saveSettings();
    applyArrowsToCanvas();
    for(const conn of state.connectors.values()){
      renderConnector(conn);
    }
    showToast(state.showArrows ? 'Pfeilspitzen eingeblendet' : 'Pfeilspitzen ausgeblendet');
  }
  function getCanvasSize(){
    const viewBox = canvas.getAttribute('viewBox');
    if(viewBox){
      const parts = viewBox.split(/\s+/).map(Number);
      if(parts.length===4 && parts.every(n=>Number.isFinite(n))){
        return {width:parts[2], height:parts[3]};
      }
    }
    const r = canvas.getBoundingClientRect();
    return {width:r.width, height:r.height};
  }
  function applyNodeConstraints(node){
    const size = getCanvasSize();
    if(!size) return;
    let {x, y} = node;
    if(!state.horizontalUnlimited){
      const minX = node.w/2;
      const maxX = Math.max(minX, size.width - node.w/2);
      x = Math.min(Math.max(x, minX), maxX);
    }
    if(!state.verticalUnlimited){
      const minY = node.h/2;
      const maxY = Math.max(minY, size.height - node.h/2);
      y = Math.min(Math.max(y, minY), maxY);
    }
    node.x = x;
    node.y = y;
  }
  function enforceConstraintsForAllNodes(){
    let changed = false;
    for(const node of state.nodes.values()){
      const prevX = node.x;
      const prevY = node.y;
      applyNodeConstraints(node);
      if(node.x !== prevX || node.y !== prevY){
        renderNode(node);
        changed = true;
      }
    }
    if(changed){
      markDirty();
      requestStageSizeUpdate();
    }
  }

  function ensureTitleFilled(){
    const title = state.title.trim();
    if(title) return true;
    updateTitleValidity();
    if(inputTitle){
      inputTitle.focus();
      if(typeof inputTitle.select === 'function') inputTitle.select();
    }
    showToast('Bitte einen Projekttitel eingeben');
    return false;
  }
  function projectFileName(ext='json'){
    const raw = state.title?.trim() || 'Projekt';
    let safe = raw
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9]+/gi, '-')
      .replace(/^-+|-+$/g, '')
      .toLowerCase();
    if(!safe) safe = 'projekt';
    const truncated = safe.slice(0, 60).replace(/-+$/g, '') || safe;
    return `${truncated}.${ext}`;
  }

  function openSettings(){ modal.classList.add('show'); modal.setAttribute('aria-hidden','false'); }
  function closeSettings(){ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }

  loadSettings();
  applyFontSize();
  applyGridToCanvas();
  updateVerbinderUI();
  updateGridUI();
  updateUnlimitedUI();
  applyArrowsToCanvas();
  updateArrowsUI();
  setSidebarCollapsed(state.sidebarCollapsed, {silent:true});
  applyPalettePosition();
  restoreAutosaveIfAny();
  updateTitleInput();

  if(btnSettings) btnSettings.addEventListener('click', openSettings);
  if(closeBtn) closeBtn.addEventListener('click', closeSettings);
  if(modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) closeSettings(); });
  if(chkVerbinder) chkVerbinder.addEventListener('change', (e)=> setShowVerbinder(e.target.checked));
  if(selectGrid) selectGrid.addEventListener('change', (e)=> setGridSize(e.target.value));
  if(toggleVerticalUnlimited) toggleVerticalUnlimited.addEventListener('change', (e)=> setVerticalUnlimited(e.target.checked));
  if(toggleHorizontalUnlimited) toggleHorizontalUnlimited.addEventListener('change', (e)=> setHorizontalUnlimited(e.target.checked));
  if(toggleArrows) toggleArrows.addEventListener('change', (e)=> setShowArrows(e.target.checked));
  if(btnFontIncrease) btnFontIncrease.addEventListener('click', ()=> adjustFontSize(FONT_SIZE_STEP));
  if(btnFontDecrease) btnFontDecrease.addEventListener('click', ()=> adjustFontSize(-FONT_SIZE_STEP));
  if(btnTogglePalette) btnTogglePalette.addEventListener('click', ()=> setSidebarCollapsed(!state.sidebarCollapsed));
  if(paletteBausteineHead) paletteBausteineHead.addEventListener('pointerdown', startPaletteDrag);
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal?.classList.contains('show')) closeSettings(); });
  if(connectorToggleArrow) connectorToggleArrow.addEventListener('click', ()=>{
    if(state.contextConnectorId){ toggleConnectorArrow(state.contextConnectorId); }
    closeConnectorMenu();
  });
  if(connectorDelete) connectorDelete.addEventListener('click', ()=>{
    if(state.contextConnectorId){ deleteConnector(state.contextConnectorId); }
    closeConnectorMenu();
  });
  if(nodeDelete) nodeDelete.addEventListener('click', ()=>{
    if(state.contextNodeId){ deleteNode(state.contextNodeId); }
    closeNodeMenu();
  });
  if(connectorMenu){
    connectorMenu.addEventListener('click', (e)=> e.stopPropagation());
    connectorMenu.addEventListener('contextmenu', (e)=> e.preventDefault());
  }
  if(nodeMenu){
    nodeMenu.addEventListener('click', (e)=> e.stopPropagation());
    nodeMenu.addEventListener('contextmenu', (e)=> e.preventDefault());
  }
  if(inputTitle){
    inputTitle.addEventListener('input', (e)=>{
      state.title = e.target.value;
      markDirty();
      updateTitleValidity();
    });
    inputTitle.addEventListener('blur', ()=>{
      const trimmed = inputTitle.value.trim();
      if(state.title !== trimmed){
        state.title = trimmed;
        markDirty();
      }
      inputTitle.value = state.title;
      updateTitleValidity();
    });
    inputTitle.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        inputTitle.blur();
        e.preventDefault();
      }
    });
  }
  if(btnNew){
    btnNew.addEventListener('click', ()=>{
      const proceed = confirm('Start new project? Unsaved changes will be lost.');
      if(!proceed) return;
      startNewProject();
    });
  }
  document.addEventListener('click', (e)=>{
    if(connectorMenuVisible && connectorMenu && !connectorMenu.contains(e.target)) closeConnectorMenu();
    if(nodeMenuVisible && nodeMenu && !nodeMenu.contains(e.target)) closeNodeMenu();
  });
  window.addEventListener('resize', handleViewportChange);
  window.addEventListener('blur', closeAllMenus);
  if(mainArea) mainArea.addEventListener('scroll', closeAllMenus);

  // Palette drag & drop
  $$('.shape').forEach(el=>{
    el.addEventListener('dragstart', (e)=>{
      e.dataTransfer.setData('text/plain', el.dataset.shape);
      e.dataTransfer.effectAllowed = 'copy';
    });
  });

  canvas.addEventListener('dragover', (e)=>{ e.preventDefault(); });
  canvas.addEventListener('drop', (e)=>{
    e.preventDefault();
    const type = e.dataTransfer.getData('text/plain');
    if(!type) return;
    if(type==='connector' && !state.showVerbinder){ showToast('Einsteiger-Modus: Verbinder deaktiviert'); return; }
    const pt = clientToSvg(e.clientX, e.clientY);
    const [x,y] = snap(pt.x, pt.y);
    const node = createNode(type, x, y);
    renderNode(node);
    select({type:'node', id:node.id});
    showToast('Baustein hinzugefügt');
  });

  function clientToSvg(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }
  function snap(x,y){
    const g = state.grid; return [Math.round(x/g)*g, Math.round(y/g)*g];
  }

  // Node creation & rendering
  function nextId(prefix){ return `${prefix}-${state.idCounter++}`; }

  function createNode(type, x, y){
    const base = { w:160, h:70 };
    let label = { terminator:'Start/Ende', process:'Prozess', decision:'Entscheidung?', io:'Ein-/Ausgabe', connector:'Verbinder' }[type] || 'Knoten';
    const node = { id: nextId('n'), type, x, y, w: base.w, h: base.h, label };
    applyNodeConstraints(node);
    state.nodes.set(node.id, node);
    markDirty();
    return node;
  }

  function renderNode(node){
    let g = document.getElementById(node.id);
    if(!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.id = node.id; g.classList.add('node','node-base'); layerNodes.appendChild(g);
      g.addEventListener('mousedown', startDragNode);
      g.addEventListener('dblclick', renameNode);
      g.addEventListener('click', nodeClick);
      g.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        select({type:'node', id:node.id});
        openNodeMenu(node.id, e.clientX, e.clientY);
      });
    }
    g.setAttribute('transform', `translate(${node.x - node.w/2}, ${node.y - node.h/2})`);
    g.innerHTML = '';

    const shape = shapeElement(node); shape.setAttribute('class','node-shape'); g.appendChild(shape);

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('text-anchor','middle');
    text.setAttribute('dominant-baseline','middle');
    text.setAttribute('aria-label', node.label || '');
    const fontSize = clampFontSize(state.fontSize);
    const lineHeight = lineHeightPx(fontSize);
    const maxTextWidth = Math.max(10, node.w - LABEL_TEXT_PADDING);
    const lines = wrapLabelText(node.label, maxTextWidth);
    const startY = node.h/2 - ((lines.length - 1) * lineHeight)/2;
    text.setAttribute('font-size', fontSize);
    text.setAttribute('font-family', FONT_FAMILY);
    text.setAttribute('font-weight', FONT_WEIGHT);
    lines.forEach((line, idx)=>{
      const tspan = document.createElementNS('http://www.w3.org/2000/svg','tspan');
      tspan.setAttribute('x', node.w/2);
      tspan.setAttribute('y', (startY + idx * lineHeight).toFixed(2));
      tspan.textContent = line || '\u200B';
      text.appendChild(tspan);
    });
    g.appendChild(text);

    updateConnectorsFor(node.id);
    requestStageSizeUpdate();
  }

  function shapeElement(node){
    const {w,h,type} = node; const ns = 'http://www.w3.org/2000/svg';
    if(type==='process'){ const r = document.createElementNS(ns,'rect'); r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx',10); return r; }
    if(type==='terminator'){ const r = document.createElementNS(ns,'rect'); r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx', Math.min(30, h/2)); return r; }
    if(type==='decision'){ const p = document.createElementNS(ns,'polygon'); p.setAttribute('points', `${w/2},0 ${w},${h/2} ${w/2},${h} 0,${h/2}`); return p; }
    if(type==='io'){ const skew=26; const p = document.createElementNS(ns,'polygon'); p.setAttribute('points', `${skew},0 ${w},0 ${w-skew},${h} 0,${h}`); return p; }
    if(type==='connector'){ const c = document.createElementNS(ns,'circle'); c.setAttribute('cx',w/2); c.setAttribute('cy',h/2); c.setAttribute('r',Math.min(w,h)/3); return c; }
    const r = document.createElementNS(ns,'rect'); r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx',8); return r;
  }

  // Selection
  function select(sel){
    $$('.selected', canvas).forEach(el=>el.classList.remove('selected'));
    state.selection = sel; if(!sel) return;
    if(sel.type==='node'){ const g = document.getElementById(sel.id); if(g) g.classList.add('selected'); }
    else if(sel.type==='connector'){ const c = document.getElementById(sel.id); if(c) c.classList.add('selected'); }
  }

  function nodeClick(e){
    e.stopPropagation();
    closeAllMenus();
    const id = this.id;
    if(e.shiftKey){
      if(!state.pendingLinkFrom){ state.pendingLinkFrom = id; select({type:'node', id}); showToast('Quelle gewählt – Ziel anklicken'); }
      else if(state.pendingLinkFrom && state.pendingLinkFrom!==id){ const conn = createConnector(state.pendingLinkFrom, id); renderConnector(conn); state.pendingLinkFrom=null; select({type:'connector', id:conn.id}); showToast('Verbunden ✓'); }
      return;
    }
    select({type:'node', id});
  }

  canvas.addEventListener('click', (e)=>{
    if(e.target===canvas){
      select(null);
      state.pendingLinkFrom=null;
    }
    closeAllMenus();
  });

  // Rename
  function renameNode(){
    closeAllMenus();
    const id = this.id; const node = state.nodes.get(id);
    const text = prompt('Neuer Text für diese Form:', node.label);
    if(text!==null){ node.label = text.trim() || node.label; renderNode(node); markDirty(); }
  }

  // Dragging
  let drag=null;
  function startDragNode(e){
    e.stopPropagation();
    closeAllMenus();
    const id=this.id;
    const node=state.nodes.get(id);
    select({type:'node',id});
    const start=clientToSvg(e.clientX,e.clientY);
    drag={id, ox:node.x, oy:node.y, sx:start.x, sy:start.y};
    window.addEventListener('mousemove', onDragMove);
    window.addEventListener('mouseup', endDrag);
  }
  function onDragMove(e){ if(!drag) return; const pt=clientToSvg(e.clientX,e.clientY); const dx=pt.x-drag.sx, dy=pt.y-drag.sy; const node=state.nodes.get(drag.id); if(!node) return; const [nx,ny]=snap(drag.ox+dx, drag.oy+dy); node.x=nx; node.y=ny; applyNodeConstraints(node); renderNode(node); }
  function endDrag(){ window.removeEventListener('mousemove', onDragMove); window.removeEventListener('mouseup', endDrag); drag=null; markDirty(); }

  // Connectors
  function createConnector(fromId, toId){
    const id = nextId('c');
    const conn = { id, fromId, toId, arrow: true };
    state.connectors.set(id, conn);
    markDirty();
    return conn;
  }
  function connectorHasArrow(conn){
    return conn?.arrow !== false;
  }
  function nodeBlocksArrow(node){
    if(!node) return true;
    const type = String(node.type || '').toLowerCase();
    if(type === 'note' || type === 'notiz' || type === 'annotation') return true;
    if(type.includes('lane')) return true;
    return false;
  }
  function shouldRenderArrow(conn){
    if(!state.showArrows) return false;
    if(!connectorHasArrow(conn)) return false;
    const from = state.nodes.get(conn.fromId);
    const to = state.nodes.get(conn.toId);
    if(!from || !to) return false;
    if(nodeBlocksArrow(from) || nodeBlocksArrow(to)) return false;
    return true;
  }
  function pointOnNodeEdge(node, target){
    const dx = target.x - node.x;
    const dy = target.y - node.y;
    if(dx===0 && dy===0) return {x:node.x, y:node.y};
    const type = String(node.type || '').toLowerCase();
    const len = Math.hypot(dx, dy) || 1;
    if(type === 'connector'){
      const r = Math.min(node.w, node.h)/2;
      return {x: node.x + (dx/len)*r, y: node.y + (dy/len)*r};
    }
    if(type === 'decision'){
      const hw = node.w/2;
      const hh = node.h/2;
      const scale = 1 / ((Math.abs(dx)/hw) + (Math.abs(dy)/hh));
      return {x: node.x + dx*scale, y: node.y + dy*scale};
    }
    const hw = node.w/2;
    const hh = node.h/2;
    let scale = Infinity;
    if(dx!==0) scale = Math.min(scale, hw/Math.abs(dx));
    if(dy!==0) scale = Math.min(scale, hh/Math.abs(dy));
    if(!isFinite(scale)) scale = 0;
    return {x: node.x + dx*scale, y: node.y + dy*scale};
  }
  function connectorEndpoints(conn, allowArrow){
    const fromNode = state.nodes.get(conn.fromId);
    const toNode = state.nodes.get(conn.toId);
    if(!fromNode || !toNode) return null;
    const fromPoint = pointOnNodeEdge(fromNode, toNode);
    const toPoint = pointOnNodeEdge(toNode, fromNode);
    if(allowArrow){
      const dx = toNode.x - fromNode.x;
      const dy = toNode.y - fromNode.y;
      const len = Math.hypot(dx, dy) || 1;
      toPoint.x -= (dx/len) * ARROW_PADDING;
      toPoint.y -= (dy/len) * ARROW_PADDING;
    }
    return {from: fromPoint, to: toPoint};
  }
  function bindConnectorEvents(conn, line, hit){
    if(!line || line.dataset.bound === '1') return;
    const id = conn.id;
    const onClick = (e)=>{
      e.stopPropagation();
      closeAllMenus();
      select({type:'connector', id});
    };
    const openMenu = (e)=>{
      e.preventDefault();
      e.stopPropagation();
      select({type:'connector', id});
      openConnectorMenu(id, e.clientX, e.clientY);
    };
    const onEnter = ()=> line.classList.add('hover');
    const onLeave = ()=> line.classList.remove('hover');
    const attach = (target)=>{
      if(!target) return;
      target.addEventListener('click', onClick);
      target.addEventListener('contextmenu', openMenu);
      target.addEventListener('dblclick', openMenu);
      target.addEventListener('mouseenter', onEnter);
      target.addEventListener('mouseleave', onLeave);
    };
    attach(line);
    attach(hit);
    line.dataset.bound = '1';
    if(hit) hit.dataset.bound = '1';
  }
  function toggleConnectorArrow(id){
    const conn = state.connectors.get(id);
    if(!conn) return;
    conn.arrow = connectorHasArrow(conn) ? false : true;
    renderConnector(conn);
    markDirty();
  }
  function renderConnector(conn){
    if(!state.nodes.has(conn.fromId) || !state.nodes.has(conn.toId)){
      const stray = document.getElementById(conn.id);
      if(stray) stray.remove();
      state.connectors.delete(conn.id);
      return;
    }
    let hit=document.getElementById(`${conn.id}-hit`);
    if(!hit){
      hit=document.createElementNS('http://www.w3.org/2000/svg','line');
      hit.id=`${conn.id}-hit`;
      hit.setAttribute('stroke','transparent');
      hit.setAttribute('stroke-width','16');
      hit.setAttribute('pointer-events','stroke');
      hit.setAttribute('stroke-linecap','round');
      hit.style.cursor='pointer';
      layerCons.appendChild(hit);
    }
    let line=document.getElementById(conn.id);
    if(!line){
      line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.id=conn.id;
      line.classList.add('connector');
      layerCons.appendChild(line);
    }
    bindConnectorEvents(conn, line, hit);
    const allowArrow = shouldRenderArrow(conn);
    const endpoints = connectorEndpoints(conn, allowArrow);
    if(!endpoints) return;
    const {from, to} = endpoints;
    line.setAttribute('x1',from.x); line.setAttribute('y1',from.y); line.setAttribute('x2',to.x); line.setAttribute('y2',to.y);
    hit.setAttribute('x1',from.x); hit.setAttribute('y1',from.y); hit.setAttribute('x2',to.x); hit.setAttribute('y2',to.y);
    line.setAttribute('marker-end', allowArrow ? 'url(#arrow)' : 'none');
    line.classList.toggle('has-arrow', allowArrow);
  }
  function updateConnectorsFor(nodeId){ for(const conn of state.connectors.values()){ if(conn.fromId===nodeId || conn.toId===nodeId) renderConnector(conn); } }

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Escape'){
      if(connectorMenuVisible || nodeMenuVisible){
        closeAllMenus();
        return;
      }
    }
    if(e.key==='Delete' || e.key==='Backspace'){
      if(state.selection){ if(state.selection.type==='node') deleteNode(state.selection.id); if(state.selection.type==='connector') deleteConnector(state.selection.id); select(null); }
    }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='d'){
      e.preventDefault(); e.stopPropagation();
      if(state.selection?.type==='node') duplicateNode(state.selection.id);
      else showToast('Tipp: Wähle zuerst eine Form – Strg/⌘+D dupliziert');
    }
  });

  function deleteNode(id){
    for(const [cid,conn] of [...state.connectors]){ if(conn.fromId===id || conn.toId===id) deleteConnector(cid); }
    state.nodes.delete(id);
    const el=document.getElementById(id); if(el) el.remove();
    if(state.contextNodeId === id) closeNodeMenu();
    markDirty();
    requestStageSizeUpdate();
  }
  function deleteConnector(id){
    state.connectors.delete(id);
    const el=document.getElementById(id);
    if(el) el.remove();
    if(state.contextConnectorId === id) closeConnectorMenu();
    const hit=document.getElementById(`${id}-hit`);
    if(hit) hit.remove();
    markDirty();
  }
  function duplicateNode(id){
    const n=state.nodes.get(id);
    if(!n) return;
    const dup={...n, id:nextId('n'), x:n.x+state.grid*2, y:n.y+state.grid*2};
    applyNodeConstraints(dup);
    state.nodes.set(dup.id, dup);
    renderNode(dup);
    select({type:'node', id:dup.id});
    markDirty();
  }

  // Serialize / Import / Export helpers
  function serializeProject(){
    return JSON.stringify({
      nodes:[...state.nodes.values()],
      connectors:[...state.connectors.values()],
      meta:{
        grid:state.grid,
        savedAt:new Date().toISOString(),
        nextId:state.idCounter,
        verticalUnlimited: state.verticalUnlimited,
        horizontalUnlimited: state.horizontalUnlimited,
        fontSize: state.fontSize,
        sidebarCollapsed: state.sidebarCollapsed,
        floatingPalette: state.palettePosition,
        maxViewportWidth: state.maxViewportWidth || 0,
        maxViewportHeight: state.maxViewportHeight || 0,
        title: state.title.trim()
      }
    }, null, 2);
  }

  function isValidSnapshot(data){
    return !!data && Array.isArray(data.nodes) && Array.isArray(data.connectors);
  }

  function loadFromData(data){
    state.nodes.clear();
    state.connectors.clear();
    layerNodes.innerHTML = '';
    layerCons.innerHTML = '';
    state.maxViewportWidth = 0;
    state.maxViewportHeight = 0;
    state.title = '';

    if(data?.meta){
      if(data.meta.hasOwnProperty('grid')){
        const g = Number(data.meta.grid);
        if(Number.isFinite(g) && g > 0) state.grid = g;
      }
      if(typeof data.meta.verticalUnlimited === 'boolean') state.verticalUnlimited = data.meta.verticalUnlimited;
      if(typeof data.meta.horizontalUnlimited === 'boolean') state.horizontalUnlimited = data.meta.horizontalUnlimited;
      const metaFontSize = Number(data.meta.fontSize);
      if(Number.isFinite(metaFontSize)) state.fontSize = clampFontSize(metaFontSize);
      if(typeof data.meta.sidebarCollapsed === 'boolean') state.sidebarCollapsed = data.meta.sidebarCollapsed;
      if(data.meta.floatingPalette) state.palettePosition = sanitizePalettePosition(data.meta.floatingPalette);
      const metaMaxWidth = Number(data.meta.maxViewportWidth);
      const metaMaxHeight = Number(data.meta.maxViewportHeight);
      if(Number.isFinite(metaMaxWidth) && metaMaxWidth > 0) state.maxViewportWidth = metaMaxWidth;
      if(Number.isFinite(metaMaxHeight) && metaMaxHeight > 0) state.maxViewportHeight = metaMaxHeight;
      if(typeof data.meta.title === 'string') state.title = data.meta.title.trim();
    }
    const baseWidth = Math.max(1, state.maxViewportWidth || state.viewportWidth || mainArea?.clientWidth || stageWrap?.clientWidth || 1);
    const baseHeight = Math.max(1, state.maxViewportHeight || state.viewportHeight || mainArea?.clientHeight || stageWrap?.clientHeight || 1);
    if(stageWrap){
      if(state.horizontalUnlimited){
        stageWrap.style.width = `${Math.floor(baseWidth)}px`;
      }else{
        stageWrap.style.width = '';
      }
      if(state.verticalUnlimited){
        stageWrap.style.height = `${Math.floor(baseHeight)}px`;
      }else{
        stageWrap.style.height = '';
      }
    }
    if(canvas){
      canvas.setAttribute('viewBox', `0 0 ${Math.floor(baseWidth)} ${Math.floor(baseHeight)}`);
      canvas.setAttribute('width', Math.floor(baseWidth));
      canvas.setAttribute('height', Math.floor(baseHeight));
    }
    applyFontSize();
    applyGridToCanvas();

    const validNodes = Array.isArray(data?.nodes) ? data.nodes : [];
    for(const rawNode of validNodes){
      if(!rawNode?.id) continue;
      const node = sanitizeNode(rawNode);
      applyNodeConstraints(node);
      state.nodes.set(node.id, node);
      renderNode(node);
    }

    const validConnectors = Array.isArray(data?.connectors) ? data.connectors : [];
    for(const rawConn of validConnectors){
      if(!rawConn?.id || !state.nodes.has(rawConn.fromId) || !state.nodes.has(rawConn.toId)) continue;
      const conn = sanitizeConnector(rawConn);
      state.connectors.set(conn.id, conn);
      renderConnector(conn);
    }

    let nextIdSeed = computeNextIdSeed();
    const metaNextId = Number(data?.meta?.nextId);
    if(Number.isFinite(metaNextId) && metaNextId > nextIdSeed) nextIdSeed = metaNextId;
    state.idCounter = Math.max(1, nextIdSeed);
    select(null);
    state.pendingLinkFrom = null;
    updateGridUI();
    updateUnlimitedUI();
    if(!state.verticalUnlimited || !state.horizontalUnlimited) enforceConstraintsForAllNodes();
    requestStageSizeUpdate();
    applyArrowsToCanvas();
    setSidebarCollapsed(state.sidebarCollapsed, {silent:true});
    applyPalettePosition();
    updateTitleInput();
    state.dirty = false;
  }

  function startNewProject(){
    closeAllMenus();
    state.nodes.clear();
    state.connectors.clear();
    layerNodes.innerHTML = '';
    layerCons.innerHTML = '';
    state.selection = null;
    state.pendingLinkFrom = null;
    state.contextConnectorId = null;
    state.contextNodeId = null;
    state.idCounter = 1;
    state.title = '';
    const baseWidth = Math.max(1, state.viewportWidth || mainArea?.clientWidth || stageWrap?.clientWidth || 1);
    const baseHeight = Math.max(1, state.viewportHeight || mainArea?.clientHeight || stageWrap?.clientHeight || 1);
    state.maxViewportWidth = baseWidth;
    state.maxViewportHeight = baseHeight;
    if(stageWrap){
      if(state.horizontalUnlimited){
        stageWrap.style.width = `${Math.floor(baseWidth)}px`;
      }else{
        stageWrap.style.width = '';
      }
      if(state.verticalUnlimited){
        stageWrap.style.height = `${Math.floor(baseHeight)}px`;
      }else{
        stageWrap.style.height = '';
      }
    }
    if(canvas){
      const w = Math.floor(baseWidth);
      const h = Math.floor(baseHeight);
      canvas.setAttribute('viewBox', `0 0 ${w} ${h}`);
      canvas.setAttribute('width', w);
      canvas.setAttribute('height', h);
    }
    applyFontSize();
    applyGridToCanvas();
    applyArrowsToCanvas();
    updateGridUI();
    updateUnlimitedUI();
    updateArrowsUI();
    updateTitleInput();
    setSidebarCollapsed(state.sidebarCollapsed, {silent:true});
    applyPalettePosition();
    requestStageSizeUpdate();
    select(null);
    try{
      localStorage.removeItem(autosaveKey());
      localStorage.removeItem(autosaveFallbackKey);
    }catch{}
    saveAutosave(true);
    state.dirty = false;
    showToast('Neues Projekt gestartet');
  }

  function sanitizeNode(raw){
    const node = {...raw};
    node.id = String(raw?.id ?? '');
    node.type = typeof raw?.type === 'string' ? raw.type : 'process';
    node.x = Number(raw?.x) || 0;
    node.y = Number(raw?.y) || 0;
    const width = Number(raw?.w);
    const height = Number(raw?.h);
    node.w = Number.isFinite(width) && width > 0 ? width : 160;
    node.h = Number.isFinite(height) && height > 0 ? height : 70;
    node.label = typeof raw?.label === 'string' ? raw.label : 'Knoten';
    return node;
  }

  function sanitizeConnector(raw){
    return {
      id: String(raw?.id ?? ''),
      fromId: String(raw?.fromId ?? ''),
      toId: String(raw?.toId ?? ''),
      arrow: raw?.arrow === false ? false : true
    };
  }

  function computeNextIdSeed(){
    let max = 0;
    const take = (id)=>{
      const match = /-(\d+)$/.exec(String(id));
      if(!match) return;
      const num = Number(match[1]);
      if(Number.isFinite(num) && num > max) max = num;
    };
    for(const id of state.nodes.keys()) take(id);
    for(const id of state.connectors.keys()) take(id);
    return max + 1;
  }

  if(fileImport){
    fileImport.addEventListener('change', (e)=>{
      const file=e.target.files?.[0]; if(!file) return; const reader=new FileReader();
      reader.onload=()=>{ try{ const data=JSON.parse(reader.result); loadFromData(data); showToast('Projekt geladen'); }catch(err){ alert('Fehler beim Laden: '+err.message); } };
      reader.readAsText(file);
    });
  }
  if(btnImport && fileImport){
    btnImport.addEventListener('click', ()=> fileImport.click());
  }

  function exportJSON(){
    if(!ensureTitleFilled()) return;
    const blob=new Blob([serializeProject()], {type:'application/json'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download=projectFileName('json');
    a.click();
  }

  function exportPNG(withGrid=false){
    if(!ensureTitleFilled()) return;
    const r = canvas.getBoundingClientRect();
    const clone = canvas.cloneNode(true);

    // Inline CSS so the blob knows our styles
    const cssVar=(name,fallback)=>{ try{ return getComputedStyle(document.documentElement).getPropertyValue(name).trim()||fallback; }catch{ return fallback; } };
    const style=document.createElementNS('http://www.w3.org/2000/svg','style');
    style.textContent = `
      .node-shape{fill:${cssVar('--node','#ffffff')};stroke:${cssVar('--node-stroke','#cbd5e1')};stroke-width:2}
      .connector{stroke:#64748b;stroke-width:2.25}
      text{fill:#111827;font:600 ${cssVar('--node-font-size','12px')}/1.2 ${cssVar('--node-font-family','system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif')}}
      marker path{fill:#64748b}
    `;
    clone.insertBefore(style, clone.firstChild);

    const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
    svg.setAttribute('width', Math.floor(r.width));
    svg.setAttribute('height', Math.floor(r.height));
    svg.setAttribute('viewBox', `0 0 ${Math.floor(r.width)} ${Math.floor(r.height)}`);
    if(!withGrid){ const bg=document.createElementNS('http://www.w3.org/2000/svg','rect'); bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width','100%'); bg.setAttribute('height','100%'); bg.setAttribute('fill','#ffffff'); svg.appendChild(bg); }
    svg.appendChild(clone);

    const s=new XMLSerializer().serializeToString(svg);
    const img=new Image();
    const url=URL.createObjectURL(new Blob([s], {type:'image/svg+xml'}));
    img.onload=()=>{
      const w=Math.floor(r.width), h=Math.floor(r.height);
      const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
      ctx.drawImage(img,0,0);
      if(withGrid){ const prev=ctx.globalCompositeOperation; ctx.globalCompositeOperation='destination-over'; drawGrid(ctx,w,h,state.grid); ctx.globalCompositeOperation=prev; }
      URL.revokeObjectURL(url);
      const png=c.toDataURL('image/png'); const a=document.createElement('a'); a.href=png;
      const base = projectFileName(withGrid ? 'png' : 'png');
      a.download = withGrid ? base.replace(/\.png$/, '-grid.png') : base;
      a.click();
    };
    img.src=url;
  }

  function drawGrid(ctx,w,h,step=20){ ctx.beginPath(); for(let x=step;x<w;x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,h); } for(let y=step;y<h;y+=step){ ctx.moveTo(0,y); ctx.lineTo(w,y); } ctx.lineWidth=1; ctx.strokeStyle='#e5e7eb'; ctx.stroke(); }

  // Export dropdown wiring
  (function(){
    const exportDropdown=document.getElementById('exportDropdown');
    const btnExport=document.getElementById('btnExport');
    const menuExport=document.getElementById('menuExport');
    function toggleExportMenu(show){ const willShow= typeof show==='boolean'? show : !menuExport.classList.contains('show'); menuExport.classList.toggle('show', willShow); menuExport.setAttribute('aria-hidden', willShow? 'false':'true'); }
    btnExport.addEventListener('click', (e)=>{ e.stopPropagation(); toggleExportMenu(); });
    document.addEventListener('click', (e)=>{ if(!exportDropdown.contains(e.target)) toggleExportMenu(false); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') toggleExportMenu(false); });
    menuExport.addEventListener('click', (e)=>{ const b=e.target.closest('button[data-action]'); if(!b) return; const a=b.dataset.action; toggleExportMenu(false); if(a==='export-json') exportJSON(); if(a==='export-png') exportPNG(false); if(a==='export-png-grid') exportPNG(true); });
  })();

  // Toast helper
  function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); clearTimeout(showToast.tid); showToast.tid=setTimeout(()=>toast.classList.remove('show'), 1400); }

  // Demo content (skipped if autosave restored)
  (function demo(){ if(state.restoredFromAutosave) return; const a=createNode('terminator',220,140); a.label='Start'; const b=createNode('process',420,140); b.label='Initialisiere'; const c=createNode('decision',620,140); c.label='Bedingung?'; const d=createNode('process',620,280); d.label='Alternative'; [a,b,c,d].forEach(renderNode); renderConnector(createConnector(a.id,b.id)); renderConnector(createConnector(b.id,c.id)); renderConnector(createConnector(c.id,d.id)); })();

  // --- Self-tests (basic & extra) ---
  (function runSelfTests(){
    try{
      const before = state.idCounter;
      const n = createNode('process', 100, 100); renderNode(n);
      console.assert(state.nodes.has(n.id), 'Node should be stored');
      duplicateNode(n.id); const dupId = `n-${before+1}`; console.assert(state.nodes.has(dupId), 'Duplicate should exist');
      const json = serializeProject(); const parsed = JSON.parse(json); console.assert(Array.isArray(parsed.nodes) && Array.isArray(parsed.connectors), 'Serialized format shape');
      const testCss = (v)=>/\$\{\s*cssVar/.test(v)===false; // no raw ${cssVar...}
      const cssOk = testCss(`.node-shape{fill:${getComputedStyle(document.documentElement).getPropertyValue('--node').trim()||'#fff'};}`);
      console.assert(cssOk, 'Template literal for CSS vars should evaluate');

      // Extra test: connector updates when moving node
      const a = createNode('process', 50, 50); const b = createNode('process', 200, 50);
      [a,b].forEach(renderNode);
      const c = createConnector(a.id, b.id); renderConnector(c);
      const line1 = document.getElementById(c.id); const oldX2 = line1.getAttribute('x2');
      b.x += 40; renderNode(b);
      const line2 = document.getElementById(c.id); console.assert(line2.getAttribute('x2') !== oldX2, 'Connector endpoints update after node move');

      // cleanup
      deleteNode(a.id); deleteNode(b.id); deleteNode(dupId); deleteNode(n.id);
      state.idCounter = before; select(null); state.dirty = false;
      console.log('%cSelf-tests passed','color:green');
    }catch(err){ console.error('Self-tests failed:', err); }
  })();

  </script>
</body>
</html>
