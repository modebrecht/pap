<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PAP Builder (Programmablaufplan) – v1.3 (Autosave & Bugfix)</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --ink:#1f2937;
      --muted:#6b7280;
      --accent:#16a34a; /* green */
      --accent-2:#06b6d4; /* cyan */
      --panel:#46474A; /* anthracite */
      --panel-ink:#f1f5f9;
      --node:#ffffff;
      --node-stroke:#cbd5e1;
      --node-selected:#3b82f6;
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --grid-step:20px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      display:grid; grid-template-columns:280px 1fr; grid-template-rows:56px 1fr; grid-template-areas:
      "header header"
      "sidebar main";
    }
    header{grid-area:header; display:flex; align-items:center; gap:12px; padding:10px 14px; background:#fff; box-shadow:var(--shadow); position:sticky; top:0; z-index:2}
    header h1{font-size:16px; margin:0; font-weight:700}
    header .spacer{flex:1}
    header button, header .file-btn-label{
      border:1px solid #d1d5db; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; transition:.15s ease; font-weight:600
    }
    header button:hover, header .file-btn-label:hover{background:#f3f4f6}
    header .file-input{display:none}

    /* Export dropdown */
    .dropdown{position:relative}
    .dropdown .menu{position:absolute; right:0; top:calc(100% + 6px); background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:var(--shadow); display:none; min-width:220px; overflow:hidden; z-index:5}
    .dropdown .menu.show{display:block}
    .dropdown .menu button{display:block; width:100%; padding:10px 12px; text-align:left; border:0; background:#fff; cursor:pointer; font-weight:600}
    .dropdown .menu button:hover{background:#f3f4f6}

    aside{grid-area:sidebar; background:var(--panel); color:var(--panel-ink); padding:14px; display:flex; flex-direction:column; gap:14px; box-shadow: inset -1px 0 0 rgba(255,255,255,.06)}
    .palette h2{margin:4px 0 8px; font-size:13px; text-transform:uppercase; letter-spacing:.08em; color:#d1d5db}
    .shape{background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.2); border-radius:12px; padding:10px; display:flex; align-items:center; gap:10px; cursor:grab; user-select:none}
    .shape + .shape{margin-top:10px}
    .shape svg{width:36px; height:28px}
    .shape strong{color:#fff}
    .shape[draggable="true"]:active{cursor:grabbing}

    main{grid-area:main; position:relative; overflow:auto}
    #stage-wrap{position:relative; min-height:100%; min-width:100%; width:100%; height:100%}

    /* SVG canvas + grid */
    #canvas{width:100%; height:100%; display:block; background:
      linear-gradient(transparent calc(var(--grid-step) - 1px), #e5e7eb calc(var(--grid-step))),
      linear-gradient(90deg, transparent calc(var(--grid-step) - 1px), #e5e7eb calc(var(--grid-step)));
      background-size:var(--grid-step) var(--grid-step); background-position:0 0;
    }

    .node-base{filter:drop-shadow(0 2px 6px rgba(0,0,0,.08))}
    .node-shape{fill:var(--node); stroke:var(--node-stroke); stroke-width:2}
    .node.selected .node-shape{stroke:var(--node-selected); stroke-width:2.5}
    .node text{font:600 12px/1.2 system-ui,Segoe UI,Roboto,Arial,sans-serif; fill:#111827; pointer-events:none}

    .connector{stroke:#64748b; stroke-width:2.25}
    .connector.selected{stroke:var(--node-selected)}

    .badge{position:absolute; top:10px; left:10px; background:#111827; color:#e5e7eb; font-size:11px; padding:4px 8px; border-radius:999px; opacity:.85}

    .toast{position:fixed; right:12px; bottom:12px; background:#111827; color:#e5e7eb; padding:10px 12px; border-radius:12px; font-weight:600; opacity:0; transform:translateY(8px); transition:.2s ease}
    .toast.show{opacity:1; transform:translateY(0)}

    /* Settings modal */
    .modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:50}
    .modal-backdrop.show{display:flex}
    .modal{background:#fff; width:min(520px, calc(100% - 32px)); border-radius:14px; box-shadow:var(--shadow); padding:16px}
    .modal-head{display:flex; align-items:center; gap:12px; justify-content:space-between; margin-bottom:6px}
    .modal-head h3{margin:0; font-size:16px}
    .modal-head button{border:1px solid #d1d5db; background:#fff; padding:6px 8px; border-radius:10px; cursor:pointer}
    .modal-head button:hover{background:#f3f4f6}
    .modal .row{display:flex; align-items:center; justify-content:space-between; gap:16px; padding:10px 0; border-top:1px solid #e5e7eb}
    .modal .row:first-of-type{border-top:none}
    .modal-tip{margin-top:12px; padding-top:10px; border-top:1px solid #e5e7eb; font-size:12px; color:var(--muted); line-height:1.4}
    .modal-tip strong{display:block; color:var(--ink); margin-bottom:4px}
    .switch{position:relative; width:48px; height:28px; flex:0 0 auto}
    .switch input{display:none}
    .switch .track{position:absolute; inset:0; background:#e5e7eb; border-radius:999px; transition:.2s}
    .switch .thumb{position:absolute; top:3px; left:3px; width:22px; height:22px; border-radius:50%; background:#fff; box-shadow:0 1px 3px rgba(0,0,0,.25); transition:.2s}
    .switch input:checked + .track{background:#3b82f6}
    .switch input:checked ~ .thumb{left:23px}
    .arrows-hidden .connector{marker-end:none !important}
  </style>
</head>
<body>
  <header>
    <h1>PAP&nbsp;Builder</h1>
    <div class="spacer"></div>
    <label class="file-btn-label" for="fileImportJSON" title="Projekt aus JSON laden">Import</label>
    <!-- Export dropdown -->
    <div class="dropdown" id="exportDropdown">
      <button id="btnExport" title="Export">EXPORT</button>
      <div class="menu" id="menuExport" role="menu" aria-hidden="true">
        <button type="button" data-action="export-json">Export JSON</button>
        <button type="button" data-action="export-png">Export PNG</button>
        <button type="button" data-action="export-png-grid">Export PNG + Linien</button>
      </div>
    </div>
    <button id="btnSettings" title="Einstellungen">Einstellungen</button>
    <input id="fileImportJSON" class="file-input" type="file" accept="application/json" />
  </header>

  <aside>
    <div class="palette">
      <h2>Bausteine</h2>
      <div class="shape" draggable="true" data-shape="terminator" title="Start/Ende">
        <svg viewBox="0 0 100 60" aria-hidden="true"><rect x="5" y="10" width="90" height="40" rx="20" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Start/Ende</strong><div style="opacity:.8;font-size:12px">Terminator</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="process" title="Prozess">
        <svg viewBox="0 0 100 60" aria-hidden="true"><rect x="5" y="10" width="90" height="40" rx="8" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Prozess</strong><div style="opacity:.8;font-size:12px">Anweisung</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="decision" title="Entscheidung">
        <svg viewBox="0 0 100 60" aria-hidden="true"><polygon points="50,5 95,30 50,55 5,30" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Entscheidung</strong><div style="opacity:.8;font-size:12px">Ja/Nein</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="io" title="Ein-/Ausgabe">
        <svg viewBox="0 0 100 60" aria-hidden="true"><polygon points="20,10 95,10 80,50 5,50" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Ein-/Ausgabe</strong><div style="opacity:.8;font-size:12px">Parallelogramm</div></div>
      </div>
      <div class="shape" draggable="true" data-shape="connector" title="Verbinder">
        <svg viewBox="0 0 100 60" aria-hidden="true"><circle cx="50" cy="30" r="16" fill="#fff" stroke="#cbd5e1" stroke-width="4"/></svg>
        <div><strong>Verbinder</strong><div style="opacity:.8;font-size:12px">Kreis</div></div>
      </div>
    </div>
    <div class="palette">
      <h2>Aktionen</h2>
      <div style="font-size:13px; color:#e5e7eb; opacity:.9; line-height:1.5">
        • Baustein links greifen → in die Fläche ziehen<br>
        • In der Fläche verschieben: Maus ziehen<br>
        • <b>Doppelklick</b> auf Form → umbenennen<br>
        • <b>Shift</b> + Klick zwei Formen → Pfeil verbinden<br>
        • <b>Entf</b> → ausgewählte Form/Verbindung löschen<br>
        • <b>Strg/⌘</b>+<b>D</b> → duplizieren
      </div>
    </div>
  </aside>

  <main>
    <div id="stage-wrap">
      <svg id="canvas" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <marker id="arrow" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto-start-reverse">
            <path d="M0,0 L8,3 L0,6 z" fill="#64748b"></path>
          </marker>
        </defs>
        <g id="connectors"></g>
        <g id="nodes"></g>
      </svg>
    </div>
  </main>

  <div class="modal-backdrop" id="settingsModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="modal-head">
        <h3 id="settingsTitle">Einstellungen</h3>
        <button id="btnCloseSettings" aria-label="Schließen">✕</button>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Snap-to-grid</div>
          <div style="font-size:12px; color:var(--muted)">Rastergröße für das Platzieren und Verschieben von Formen</div>
        </div>
        <select id="selectGrid" style="padding:6px 8px; border-radius:10px; border:1px solid #d1d5db;">
          <option value="10">10px</option>
          <option value="20">20px (Standard)</option>
          <option value="30">30px</option>
          <option value="40">40px</option>
          <option value="50">50px</option>
          <option value="60">60px</option>
          <option value="70">70px</option>
          <option value="80">80px</option>
        </select>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Vertikal: unbegrenzt</div>
          <div style="font-size:12px; color:var(--muted)">Deaktivieren, um den Arbeitsbereich nach oben/unten zu begrenzen</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleVerticalUnlimited" checked>
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Horizontal: unbegrenzt</div>
          <div style="font-size:12px; color:var(--muted)">Aktivieren, um den Arbeitsbereich nach links/rechts freizugeben</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleHorizontalUnlimited">
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Pfeilspitzen anzeigen</div>
          <div style="font-size:12px; color:var(--muted)">Richtung der Verbindungen mit einer Pfeilspitze markieren</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleArrows" checked>
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="row">
        <div>
          <div style="font-weight:600">Verbinder anzeigen</div>
          <div style="font-size:12px; color:var(--muted)">Für Einsteiger standardmäßig aus – später zuschalten</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="toggleVerbinder">
          <span class="track"></span>
          <span class="thumb"></span>
        </label>
      </div>
      <div class="modal-tip">
        <strong>Tipp:</strong> Doppelklick um Text zu &auml;ndern &middot; Shift&rarr; zwei Formen anklicken f&uuml;r Verbindung &middot; Entf zum L&ouml;schen
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
  // --- State ---
  const state = {
    nodes: new Map(),
    connectors: new Map(),
    selection: null,
    pendingLinkFrom: null,
    grid: 20,
    idCounter: 1,
    showVerbinder: false,
    verticalUnlimited: true,
    horizontalUnlimited: false,
    viewportWidth: 0,
    viewportHeight: 0,
    showArrows: true,
    dirty: false,
    tabId: null,
    restoredFromAutosave: false
  };

  const $ = (sel,root=document)=>root.querySelector(sel);
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
  const canvas = document.getElementById('canvas');
  const layerNodes = document.getElementById('nodes');
  const layerCons = document.getElementById('connectors');
  const toast = document.getElementById('toast');
  const stageWrap = document.getElementById('stage-wrap');
  const mainArea = document.querySelector('main');
  const ARROW_PADDING = 0;

  // --- Autosave (per tab) ---
  function ensureTabId(){
    try{
      let id = sessionStorage.getItem('pap.tabId');
      if(!id){ id = (window.crypto?.randomUUID?.() || (Date.now().toString(36)+Math.random().toString(36).slice(2))); sessionStorage.setItem('pap.tabId', id); }
      return id;
    }catch{ return 'tab-'+Date.now().toString(36); }
  }
  state.tabId = ensureTabId();
  const autosaveKey = ()=>`pap.autosave.${state.tabId}`;
  const autosaveFallbackKey = 'pap.autosave.latest';
  const markDirty = ()=>{ state.dirty = true; };
  function saveAutosave(force=false){
    if(!force && !state.dirty) return;
    try{
      const json = serializeProject();
      localStorage.setItem(autosaveKey(), json);
      localStorage.setItem(autosaveFallbackKey, json);
      state.dirty = false;
    }catch(err){
      console.warn('Autosave konnte nicht gespeichert werden', err);
    }
  }
  function readAutosaveSnapshot(){
    const keys = [autosaveKey(), autosaveFallbackKey];
    for(const key of keys){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) continue;
        const data = JSON.parse(raw);
        if(isValidSnapshot(data)) return data;
        console.warn('Autosave verworfen (ungültiges Format)', key, data);
      }catch(err){
        console.warn('Autosave konnte nicht geladen werden', err);
      }
    }
    return null;
  }
  function restoreAutosaveIfAny(){
    const snapshot = readAutosaveSnapshot();
    if(!snapshot) return;
    loadFromData(snapshot);
    state.restoredFromAutosave = true;
    showToast('Autosave geladen');
  }
  setInterval(()=>saveAutosave(true), 30000);
  window.addEventListener('beforeunload', ()=>{ try{ saveAutosave(true); }catch{} });

  // Resize SVG viewBox to pixel size for easy math
  const resizeCanvas = () => {
    const rectSource = mainArea || canvas.parentElement || document.body;
    const rect = rectSource.getBoundingClientRect();
    state.viewportWidth = Math.max(1, Math.floor(rect.width));
    state.viewportHeight = Math.max(1, Math.floor(rect.height));
    requestStageSizeUpdate();
  };
  if(mainArea){
    new ResizeObserver(resizeCanvas).observe(mainArea);
  }else{
    new ResizeObserver(resizeCanvas).observe(document.body);
  }
  window.addEventListener('load', resizeCanvas);

  // Einstellungen (Modal) & Verbinder-Präferenz
  function loadSettings(){
    try{
      const raw = localStorage.getItem('pap.settings');
      if(!raw) return;
      const s = JSON.parse(raw);
      if(typeof s.showVerbinder==='boolean') state.showVerbinder = s.showVerbinder;
      const grid = Number(s.grid);
      if(Number.isFinite(grid) && grid > 0) state.grid = grid;
      if(typeof s.verticalUnlimited==='boolean') state.verticalUnlimited = s.verticalUnlimited;
      if(typeof s.horizontalUnlimited==='boolean') state.horizontalUnlimited = s.horizontalUnlimited;
      if(typeof s.showArrows==='boolean') state.showArrows = s.showArrows;
    }catch{}
  }
  function saveSettings(){
    try{
      localStorage.setItem('pap.settings', JSON.stringify({
        showVerbinder: state.showVerbinder,
        grid: state.grid,
        verticalUnlimited: state.verticalUnlimited,
        horizontalUnlimited: state.horizontalUnlimited,
        showArrows: state.showArrows
      }));
    }catch{}
  }
  const btnSettings = document.getElementById('btnSettings');
  const modal = document.getElementById('settingsModal');
  const closeBtn = document.getElementById('btnCloseSettings');
  const chkVerbinder = document.getElementById('toggleVerbinder');
  const verbinderTile = document.querySelector('.shape[data-shape="connector"]');
  const selectGrid = document.getElementById('selectGrid');
  const toggleVerticalUnlimited = document.getElementById('toggleVerticalUnlimited');
  const toggleHorizontalUnlimited = document.getElementById('toggleHorizontalUnlimited');
  const toggleArrows = document.getElementById('toggleArrows');

  function updateVerbinderUI(){
    if(verbinderTile) verbinderTile.style.display = state.showVerbinder ? '' : 'none';
    if(chkVerbinder) chkVerbinder.checked = !!state.showVerbinder;
  }
  function updateGridUI(){
    if(!selectGrid) return;
    const value = String(state.grid);
    let option = Array.from(selectGrid.options).find(opt=>opt.value===value);
    if(!option){
      option = document.createElement('option');
      option.value = value;
      option.textContent = `${value}px`;
      selectGrid.appendChild(option);
    }
    selectGrid.value = value;
  }
  function updateUnlimitedUI(){
    if(toggleVerticalUnlimited) toggleVerticalUnlimited.checked = !!state.verticalUnlimited;
    if(toggleHorizontalUnlimited) toggleHorizontalUnlimited.checked = !!state.horizontalUnlimited;
  }
  function updateArrowsUI(){
    if(toggleArrows) toggleArrows.checked = !!state.showArrows;
  }
  function applyGridToCanvas(){
    document.documentElement.style.setProperty('--grid-step', `${state.grid}px`);
  }
  function applyArrowsToCanvas(){
    if(canvas){
      canvas.classList.toggle('arrows-hidden', !state.showArrows);
    }
  }
  const stageMargin = 200;
  let stageSizeRaf = 0;
  function computeNodeExtents(){
    if(state.nodes.size===0) return null;
    let maxX = 0;
    let maxY = 0;
    for(const node of state.nodes.values()){
      maxX = Math.max(maxX, node.x + node.w/2);
      maxY = Math.max(maxY, node.y + node.h/2);
    }
    return {maxX, maxY};
  }
  function updateStageSize(){
    if(!stageWrap || !canvas) return;
    const baseWidth = Math.max(1, state.viewportWidth || mainArea?.clientWidth || stageWrap.clientWidth || 1);
    const baseHeight = Math.max(1, state.viewportHeight || mainArea?.clientHeight || stageWrap.clientHeight || 1);
    let targetWidth = baseWidth;
    let targetHeight = baseHeight;
    const extents = computeNodeExtents();
    if(state.horizontalUnlimited && extents){
      const requiredWidth = Math.max(baseWidth, Math.ceil(extents.maxX + stageMargin));
      targetWidth = requiredWidth;
    }
    if(state.verticalUnlimited && extents){
      const requiredHeight = Math.max(baseHeight, Math.ceil(extents.maxY + stageMargin));
      targetHeight = requiredHeight;
    }
    stageWrap.style.width = state.horizontalUnlimited ? `${targetWidth}px` : '';
    stageWrap.style.height = state.verticalUnlimited ? `${targetHeight}px` : '';
    const w = Math.floor(targetWidth);
    const h = Math.floor(targetHeight);
    canvas.setAttribute('viewBox', `0 0 ${w} ${h}`);
    canvas.setAttribute('width', w);
    canvas.setAttribute('height', h);
    if(!state.verticalUnlimited || !state.horizontalUnlimited) enforceConstraintsForAllNodes();
  }
  function requestStageSizeUpdate(){
    if(stageSizeRaf) cancelAnimationFrame(stageSizeRaf);
    stageSizeRaf = requestAnimationFrame(()=>{
      stageSizeRaf = 0;
      updateStageSize();
    });
  }
  function setShowVerbinder(v){
    state.showVerbinder = !!v;
    updateVerbinderUI();
    saveSettings();
    showToast(state.showVerbinder ? 'Verbinder eingeblendet' : 'Verbinder ausgeblendet');
  }
  function setGridSize(value){
    const size = Number(value);
    if(!Number.isFinite(size) || size <= 0) return;
    if(state.grid === size){ updateGridUI(); return; }
    state.grid = size;
    applyGridToCanvas();
    updateGridUI();
    saveSettings();
    markDirty();
    showToast(`Snap-to-grid: ${size}px`);
  }
  function setVerticalUnlimited(v){
    state.verticalUnlimited = !!v;
    updateUnlimitedUI();
    saveSettings();
    markDirty();
    if(!state.verticalUnlimited) enforceConstraintsForAllNodes();
    requestStageSizeUpdate();
    showToast(state.verticalUnlimited ? 'Vertikale Begrenzung aus' : 'Vertikale Begrenzung an');
  }
  function setHorizontalUnlimited(v){
    state.horizontalUnlimited = !!v;
    updateUnlimitedUI();
    saveSettings();
    markDirty();
    if(!state.horizontalUnlimited) enforceConstraintsForAllNodes();
    requestStageSizeUpdate();
    showToast(state.horizontalUnlimited ? 'Horizontale Begrenzung aus' : 'Horizontale Begrenzung an');
  }
  function setShowArrows(v){
    const next = !!v;
    if(state.showArrows === next){
      updateArrowsUI();
      return;
    }
    state.showArrows = next;
    updateArrowsUI();
    saveSettings();
    applyArrowsToCanvas();
    for(const conn of state.connectors.values()){
      renderConnector(conn);
    }
    showToast(state.showArrows ? 'Pfeilspitzen eingeblendet' : 'Pfeilspitzen ausgeblendet');
  }
  function getCanvasSize(){
    const viewBox = canvas.getAttribute('viewBox');
    if(viewBox){
      const parts = viewBox.split(/\s+/).map(Number);
      if(parts.length===4 && parts.every(n=>Number.isFinite(n))){
        return {width:parts[2], height:parts[3]};
      }
    }
    const r = canvas.getBoundingClientRect();
    return {width:r.width, height:r.height};
  }
  function applyNodeConstraints(node){
    const size = getCanvasSize();
    if(!size) return;
    let {x, y} = node;
    if(!state.horizontalUnlimited){
      const minX = node.w/2;
      const maxX = Math.max(minX, size.width - node.w/2);
      x = Math.min(Math.max(x, minX), maxX);
    }
    if(!state.verticalUnlimited){
      const minY = node.h/2;
      const maxY = Math.max(minY, size.height - node.h/2);
      y = Math.min(Math.max(y, minY), maxY);
    }
    node.x = x;
    node.y = y;
  }
  function enforceConstraintsForAllNodes(){
    let changed = false;
    for(const node of state.nodes.values()){
      const prevX = node.x;
      const prevY = node.y;
      applyNodeConstraints(node);
      if(node.x !== prevX || node.y !== prevY){
        renderNode(node);
        changed = true;
      }
    }
    if(changed){
      markDirty();
      requestStageSizeUpdate();
    }
  }

  function openSettings(){ modal.classList.add('show'); modal.setAttribute('aria-hidden','false'); }
  function closeSettings(){ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }

  loadSettings();
  applyGridToCanvas();
  updateVerbinderUI();
  updateGridUI();
  updateUnlimitedUI();
  applyArrowsToCanvas();
  updateArrowsUI();
  restoreAutosaveIfAny();

  if(btnSettings) btnSettings.addEventListener('click', openSettings);
  if(closeBtn) closeBtn.addEventListener('click', closeSettings);
  if(modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) closeSettings(); });
  if(chkVerbinder) chkVerbinder.addEventListener('change', (e)=> setShowVerbinder(e.target.checked));
  if(selectGrid) selectGrid.addEventListener('change', (e)=> setGridSize(e.target.value));
  if(toggleVerticalUnlimited) toggleVerticalUnlimited.addEventListener('change', (e)=> setVerticalUnlimited(e.target.checked));
  if(toggleHorizontalUnlimited) toggleHorizontalUnlimited.addEventListener('change', (e)=> setHorizontalUnlimited(e.target.checked));
  if(toggleArrows) toggleArrows.addEventListener('change', (e)=> setShowArrows(e.target.checked));
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal?.classList.contains('show')) closeSettings(); });

  // Palette drag & drop
  $$('.shape').forEach(el=>{
    el.addEventListener('dragstart', (e)=>{
      e.dataTransfer.setData('text/plain', el.dataset.shape);
      e.dataTransfer.effectAllowed = 'copy';
    });
  });

  canvas.addEventListener('dragover', (e)=>{ e.preventDefault(); });
  canvas.addEventListener('drop', (e)=>{
    e.preventDefault();
    const type = e.dataTransfer.getData('text/plain');
    if(!type) return;
    if(type==='connector' && !state.showVerbinder){ showToast('Einsteiger-Modus: Verbinder deaktiviert'); return; }
    const pt = clientToSvg(e.clientX, e.clientY);
    const [x,y] = snap(pt.x, pt.y);
    const node = createNode(type, x, y);
    renderNode(node);
    select({type:'node', id:node.id});
    showToast('Baustein hinzugefügt');
  });

  function clientToSvg(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }
  function snap(x,y){
    const g = state.grid; return [Math.round(x/g)*g, Math.round(y/g)*g];
  }

  // Node creation & rendering
  function nextId(prefix){ return `${prefix}-${state.idCounter++}`; }

  function createNode(type, x, y){
    const base = { w:160, h:70 };
    let label = { terminator:'Start/Ende', process:'Prozess', decision:'Entscheidung?', io:'Ein-/Ausgabe', connector:'Verbinder' }[type] || 'Knoten';
    const node = { id: nextId('n'), type, x, y, w: base.w, h: base.h, label };
    applyNodeConstraints(node);
    state.nodes.set(node.id, node);
    markDirty();
    return node;
  }

  function renderNode(node){
    let g = document.getElementById(node.id);
    if(!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.id = node.id; g.classList.add('node','node-base'); layerNodes.appendChild(g);
      g.addEventListener('mousedown', startDragNode);
      g.addEventListener('dblclick', renameNode);
      g.addEventListener('click', nodeClick);
    }
    g.setAttribute('transform', `translate(${node.x - node.w/2}, ${node.y - node.h/2})`);
    g.innerHTML = '';

    const shape = shapeElement(node); shape.setAttribute('class','node-shape'); g.appendChild(shape);

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', node.w/2); text.setAttribute('y', node.h/2);
    text.setAttribute('text-anchor','middle'); text.setAttribute('dominant-baseline','middle');
    text.textContent = node.label; g.appendChild(text);

    updateConnectorsFor(node.id);
    requestStageSizeUpdate();
  }

  function shapeElement(node){
    const {w,h,type} = node; const ns = 'http://www.w3.org/2000/svg';
    if(type==='process'){ const r = document.createElementNS(ns,'rect'); r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx',10); return r; }
    if(type==='terminator'){ const r = document.createElementNS(ns,'rect'); r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx', Math.min(30, h/2)); return r; }
    if(type==='decision'){ const p = document.createElementNS(ns,'polygon'); p.setAttribute('points', `${w/2},0 ${w},${h/2} ${w/2},${h} 0,${h/2}`); return p; }
    if(type==='io'){ const skew=26; const p = document.createElementNS(ns,'polygon'); p.setAttribute('points', `${skew},0 ${w},0 ${w-skew},${h} 0,${h}`); return p; }
    if(type==='connector'){ const c = document.createElementNS(ns,'circle'); c.setAttribute('cx',w/2); c.setAttribute('cy',h/2); c.setAttribute('r',Math.min(w,h)/3); return c; }
    const r = document.createElementNS(ns,'rect'); r.setAttribute('x',0); r.setAttribute('y',0); r.setAttribute('width',w); r.setAttribute('height',h); r.setAttribute('rx',8); return r;
  }

  // Selection
  function select(sel){
    $$('.selected', canvas).forEach(el=>el.classList.remove('selected'));
    state.selection = sel; if(!sel) return;
    if(sel.type==='node'){ const g = document.getElementById(sel.id); if(g) g.classList.add('selected'); }
    else if(sel.type==='connector'){ const c = document.getElementById(sel.id); if(c) c.classList.add('selected'); }
  }

  function nodeClick(e){
    e.stopPropagation(); const id = this.id;
    if(e.shiftKey){
      if(!state.pendingLinkFrom){ state.pendingLinkFrom = id; select({type:'node', id}); showToast('Quelle gewählt – Ziel anklicken'); }
      else if(state.pendingLinkFrom && state.pendingLinkFrom!==id){ const conn = createConnector(state.pendingLinkFrom, id); renderConnector(conn); state.pendingLinkFrom=null; select({type:'connector', id:conn.id}); showToast('Verbunden ✓'); }
      return;
    }
    select({type:'node', id});
  }

  canvas.addEventListener('click', (e)=>{ if(e.target===canvas){ select(null); state.pendingLinkFrom=null; }});

  // Rename
  function renameNode(){
    const id = this.id; const node = state.nodes.get(id);
    const text = prompt('Neuer Text für diese Form:', node.label);
    if(text!==null){ node.label = text.trim() || node.label; renderNode(node); markDirty(); }
  }

  // Dragging
  let drag=null;
  function startDragNode(e){ e.stopPropagation(); const id=this.id; const node=state.nodes.get(id); select({type:'node',id}); const start=clientToSvg(e.clientX,e.clientY); drag={id, ox:node.x, oy:node.y, sx:start.x, sy:start.y}; window.addEventListener('mousemove', onDragMove); window.addEventListener('mouseup', endDrag); }
  function onDragMove(e){ if(!drag) return; const pt=clientToSvg(e.clientX,e.clientY); const dx=pt.x-drag.sx, dy=pt.y-drag.sy; const node=state.nodes.get(drag.id); if(!node) return; const [nx,ny]=snap(drag.ox+dx, drag.oy+dy); node.x=nx; node.y=ny; applyNodeConstraints(node); renderNode(node); }
  function endDrag(){ window.removeEventListener('mousemove', onDragMove); window.removeEventListener('mouseup', endDrag); drag=null; markDirty(); }

  // Connectors
  function createConnector(fromId, toId){
    const id = nextId('c');
    const conn = { id, fromId, toId };
    state.connectors.set(id, conn);
    markDirty();
    return conn;
  }
  function nodeBlocksArrow(node){
    if(!node) return true;
    const type = String(node.type || '').toLowerCase();
    if(type === 'note' || type === 'notiz' || type === 'annotation') return true;
    if(type.includes('lane')) return true;
    return false;
  }
  function shouldRenderArrow(conn){
    if(!state.showArrows) return false;
    const from = state.nodes.get(conn.fromId);
    const to = state.nodes.get(conn.toId);
    if(!from || !to) return false;
    if(nodeBlocksArrow(from) || nodeBlocksArrow(to)) return false;
    return true;
  }
  function pointOnNodeEdge(node, target){
    const dx = target.x - node.x;
    const dy = target.y - node.y;
    if(dx===0 && dy===0) return {x:node.x, y:node.y};
    const type = String(node.type || '').toLowerCase();
    const len = Math.hypot(dx, dy) || 1;
    if(type === 'connector'){
      const r = Math.min(node.w, node.h)/2;
      return {x: node.x + (dx/len)*r, y: node.y + (dy/len)*r};
    }
    if(type === 'decision'){
      const hw = node.w/2;
      const hh = node.h/2;
      const scale = 1 / ((Math.abs(dx)/hw) + (Math.abs(dy)/hh));
      return {x: node.x + dx*scale, y: node.y + dy*scale};
    }
    const hw = node.w/2;
    const hh = node.h/2;
    let scale = Infinity;
    if(dx!==0) scale = Math.min(scale, hw/Math.abs(dx));
    if(dy!==0) scale = Math.min(scale, hh/Math.abs(dy));
    if(!isFinite(scale)) scale = 0;
    return {x: node.x + dx*scale, y: node.y + dy*scale};
  }
  function connectorEndpoints(conn, allowArrow){
    const fromNode = state.nodes.get(conn.fromId);
    const toNode = state.nodes.get(conn.toId);
    if(!fromNode || !toNode) return null;
    const fromPoint = pointOnNodeEdge(fromNode, toNode);
    const toPoint = pointOnNodeEdge(toNode, fromNode);
    if(allowArrow){
      const dx = toNode.x - fromNode.x;
      const dy = toNode.y - fromNode.y;
      const len = Math.hypot(dx, dy) || 1;
      toPoint.x -= (dx/len) * ARROW_PADDING;
      toPoint.y -= (dy/len) * ARROW_PADDING;
    }
    return {from: fromPoint, to: toPoint};
  }
  function renderConnector(conn){
    if(!state.nodes.has(conn.fromId) || !state.nodes.has(conn.toId)){
      const stray = document.getElementById(conn.id);
      if(stray) stray.remove();
      state.connectors.delete(conn.id);
      return;
    }
    let line=document.getElementById(conn.id);
    if(!line){
      line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.id=conn.id;
      line.classList.add('connector');
      layerCons.appendChild(line);
      line.addEventListener('click', (e)=>{ e.stopPropagation(); select({type:'connector', id:conn.id}); });
    }
    const allowArrow = shouldRenderArrow(conn);
    const endpoints = connectorEndpoints(conn, allowArrow);
    if(!endpoints) return;
    const {from, to} = endpoints;
    line.setAttribute('x1',from.x); line.setAttribute('y1',from.y); line.setAttribute('x2',to.x); line.setAttribute('y2',to.y);
    line.setAttribute('marker-end', allowArrow ? 'url(#arrow)' : 'none');
    line.classList.toggle('has-arrow', allowArrow);
  }
  function updateConnectorsFor(nodeId){ for(const conn of state.connectors.values()){ if(conn.fromId===nodeId || conn.toId===nodeId) renderConnector(conn); } }

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Delete' || e.key==='Backspace'){
      if(state.selection){ if(state.selection.type==='node') deleteNode(state.selection.id); if(state.selection.type==='connector') deleteConnector(state.selection.id); select(null); }
    }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='d'){
      e.preventDefault(); e.stopPropagation();
      if(state.selection?.type==='node') duplicateNode(state.selection.id);
      else showToast('Tipp: Wähle zuerst eine Form – Strg/⌘+D dupliziert');
    }
  });

  function deleteNode(id){
    for(const [cid,conn] of [...state.connectors]){ if(conn.fromId===id || conn.toId===id) deleteConnector(cid); }
    state.nodes.delete(id);
    const el=document.getElementById(id); if(el) el.remove();
    markDirty();
    requestStageSizeUpdate();
  }
  function deleteConnector(id){ state.connectors.delete(id); const el=document.getElementById(id); if(el) el.remove(); markDirty(); }
  function duplicateNode(id){
    const n=state.nodes.get(id);
    if(!n) return;
    const dup={...n, id:nextId('n'), x:n.x+state.grid*2, y:n.y+state.grid*2};
    applyNodeConstraints(dup);
    state.nodes.set(dup.id, dup);
    renderNode(dup);
    select({type:'node', id:dup.id});
    markDirty();
  }

  // Serialize / Import / Export helpers
  function serializeProject(){
    return JSON.stringify({
      nodes:[...state.nodes.values()],
      connectors:[...state.connectors.values()],
      meta:{
        grid:state.grid,
        savedAt:new Date().toISOString(),
        nextId:state.idCounter,
        verticalUnlimited: state.verticalUnlimited,
        horizontalUnlimited: state.horizontalUnlimited
      }
    }, null, 2);
  }

  function isValidSnapshot(data){
    return !!data && Array.isArray(data.nodes) && Array.isArray(data.connectors);
  }

  function loadFromData(data){
    state.nodes.clear();
    state.connectors.clear();
    layerNodes.innerHTML = '';
    layerCons.innerHTML = '';

    if(data?.meta){
      if(data.meta.hasOwnProperty('grid')){
        const g = Number(data.meta.grid);
        if(Number.isFinite(g) && g > 0) state.grid = g;
      }
      if(typeof data.meta.verticalUnlimited === 'boolean') state.verticalUnlimited = data.meta.verticalUnlimited;
      if(typeof data.meta.horizontalUnlimited === 'boolean') state.horizontalUnlimited = data.meta.horizontalUnlimited;
    }
    applyGridToCanvas();

    const validNodes = Array.isArray(data?.nodes) ? data.nodes : [];
    for(const rawNode of validNodes){
      if(!rawNode?.id) continue;
      const node = sanitizeNode(rawNode);
      applyNodeConstraints(node);
      state.nodes.set(node.id, node);
      renderNode(node);
    }

    const validConnectors = Array.isArray(data?.connectors) ? data.connectors : [];
    for(const rawConn of validConnectors){
      if(!rawConn?.id || !state.nodes.has(rawConn.fromId) || !state.nodes.has(rawConn.toId)) continue;
      const conn = sanitizeConnector(rawConn);
      state.connectors.set(conn.id, conn);
      renderConnector(conn);
    }

    let nextIdSeed = computeNextIdSeed();
    const metaNextId = Number(data?.meta?.nextId);
    if(Number.isFinite(metaNextId) && metaNextId > nextIdSeed) nextIdSeed = metaNextId;
    state.idCounter = Math.max(1, nextIdSeed);
    select(null);
    state.pendingLinkFrom = null;
    updateGridUI();
    updateUnlimitedUI();
    if(!state.verticalUnlimited || !state.horizontalUnlimited) enforceConstraintsForAllNodes();
    requestStageSizeUpdate();
    applyArrowsToCanvas();
    state.dirty = false;
  }

  function sanitizeNode(raw){
    const node = {...raw};
    node.id = String(raw?.id ?? '');
    node.type = typeof raw?.type === 'string' ? raw.type : 'process';
    node.x = Number(raw?.x) || 0;
    node.y = Number(raw?.y) || 0;
    const width = Number(raw?.w);
    const height = Number(raw?.h);
    node.w = Number.isFinite(width) && width > 0 ? width : 160;
    node.h = Number.isFinite(height) && height > 0 ? height : 70;
    node.label = typeof raw?.label === 'string' ? raw.label : 'Knoten';
    return node;
  }

  function sanitizeConnector(raw){
    return {
      id: String(raw?.id ?? ''),
      fromId: String(raw?.fromId ?? ''),
      toId: String(raw?.toId ?? '')
    };
  }

  function computeNextIdSeed(){
    let max = 0;
    const take = (id)=>{
      const match = /-(\d+)$/.exec(String(id));
      if(!match) return;
      const num = Number(match[1]);
      if(Number.isFinite(num) && num > max) max = num;
    };
    for(const id of state.nodes.keys()) take(id);
    for(const id of state.connectors.keys()) take(id);
    return max + 1;
  }

  document.getElementById('fileImportJSON').addEventListener('change', (e)=>{
    const file=e.target.files?.[0]; if(!file) return; const reader=new FileReader();
    reader.onload=()=>{ try{ const data=JSON.parse(reader.result); loadFromData(data); showToast('Projekt geladen'); }catch(err){ alert('Fehler beim Laden: '+err.message); } };
    reader.readAsText(file);
  });

  function exportJSON(){ const blob=new Blob([serializeProject()], {type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='pap-project.json'; a.click(); }

  function exportPNG(withGrid=false){
    const r = canvas.getBoundingClientRect();
    const clone = canvas.cloneNode(true);

    // Inline CSS so the blob knows our styles
    const cssVar=(name,fallback)=>{ try{ return getComputedStyle(document.documentElement).getPropertyValue(name).trim()||fallback; }catch{ return fallback; } };
    const style=document.createElementNS('http://www.w3.org/2000/svg','style');
    style.textContent = `
      .node-shape{fill:${cssVar('--node','#ffffff')};stroke:${cssVar('--node-stroke','#cbd5e1')};stroke-width:2}
      .connector{stroke:#64748b;stroke-width:2.25}
      text{fill:#111827;font:600 12px/1.2 system-ui,Segoe UI,Roboto,Arial,sans-serif}
      marker path{fill:#64748b}
    `;
    clone.insertBefore(style, clone.firstChild);

    const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
    svg.setAttribute('width', Math.floor(r.width));
    svg.setAttribute('height', Math.floor(r.height));
    svg.setAttribute('viewBox', `0 0 ${Math.floor(r.width)} ${Math.floor(r.height)}`);
    if(!withGrid){ const bg=document.createElementNS('http://www.w3.org/2000/svg','rect'); bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width','100%'); bg.setAttribute('height','100%'); bg.setAttribute('fill','#ffffff'); svg.appendChild(bg); }
    svg.appendChild(clone);

    const s=new XMLSerializer().serializeToString(svg);
    const img=new Image();
    const url=URL.createObjectURL(new Blob([s], {type:'image/svg+xml'}));
    img.onload=()=>{
      const w=Math.floor(r.width), h=Math.floor(r.height);
      const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
      ctx.drawImage(img,0,0);
      if(withGrid){ const prev=ctx.globalCompositeOperation; ctx.globalCompositeOperation='destination-over'; drawGrid(ctx,w,h,state.grid); ctx.globalCompositeOperation=prev; }
      URL.revokeObjectURL(url);
      const png=c.toDataURL('image/png'); const a=document.createElement('a'); a.href=png; a.download=withGrid?'pap-export-grid.png':'pap-export.png'; a.click();
    };
    img.src=url;
  }

  function drawGrid(ctx,w,h,step=20){ ctx.beginPath(); for(let x=step;x<w;x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,h); } for(let y=step;y<h;y+=step){ ctx.moveTo(0,y); ctx.lineTo(w,y); } ctx.lineWidth=1; ctx.strokeStyle='#e5e7eb'; ctx.stroke(); }

  // Export dropdown wiring
  (function(){
    const exportDropdown=document.getElementById('exportDropdown');
    const btnExport=document.getElementById('btnExport');
    const menuExport=document.getElementById('menuExport');
    function toggleExportMenu(show){ const willShow= typeof show==='boolean'? show : !menuExport.classList.contains('show'); menuExport.classList.toggle('show', willShow); menuExport.setAttribute('aria-hidden', willShow? 'false':'true'); }
    btnExport.addEventListener('click', (e)=>{ e.stopPropagation(); toggleExportMenu(); });
    document.addEventListener('click', (e)=>{ if(!exportDropdown.contains(e.target)) toggleExportMenu(false); });
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') toggleExportMenu(false); });
    menuExport.addEventListener('click', (e)=>{ const b=e.target.closest('button[data-action]'); if(!b) return; const a=b.dataset.action; toggleExportMenu(false); if(a==='export-json') exportJSON(); if(a==='export-png') exportPNG(false); if(a==='export-png-grid') exportPNG(true); });
  })();

  // Toast helper
  function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); clearTimeout(showToast.tid); showToast.tid=setTimeout(()=>toast.classList.remove('show'), 1400); }

  // Demo content (skipped if autosave restored)
  (function demo(){ if(state.restoredFromAutosave) return; const a=createNode('terminator',220,140); a.label='Start'; const b=createNode('process',420,140); b.label='Initialisiere'; const c=createNode('decision',620,140); c.label='Bedingung?'; const d=createNode('process',620,280); d.label='Alternative'; [a,b,c,d].forEach(renderNode); renderConnector(createConnector(a.id,b.id)); renderConnector(createConnector(b.id,c.id)); renderConnector(createConnector(c.id,d.id)); })();

  // --- Self-tests (basic & extra) ---
  (function runSelfTests(){
    try{
      const before = state.idCounter;
      const n = createNode('process', 100, 100); renderNode(n);
      console.assert(state.nodes.has(n.id), 'Node should be stored');
      duplicateNode(n.id); const dupId = `n-${before+1}`; console.assert(state.nodes.has(dupId), 'Duplicate should exist');
      const json = serializeProject(); const parsed = JSON.parse(json); console.assert(Array.isArray(parsed.nodes) && Array.isArray(parsed.connectors), 'Serialized format shape');
      const testCss = (v)=>/\$\{\s*cssVar/.test(v)===false; // no raw ${cssVar...}
      const cssOk = testCss(`.node-shape{fill:${getComputedStyle(document.documentElement).getPropertyValue('--node').trim()||'#fff'};}`);
      console.assert(cssOk, 'Template literal for CSS vars should evaluate');

      // Extra test: connector updates when moving node
      const a = createNode('process', 50, 50); const b = createNode('process', 200, 50);
      [a,b].forEach(renderNode);
      const c = createConnector(a.id, b.id); renderConnector(c);
      const line1 = document.getElementById(c.id); const oldX2 = line1.getAttribute('x2');
      b.x += 40; renderNode(b);
      const line2 = document.getElementById(c.id); console.assert(line2.getAttribute('x2') !== oldX2, 'Connector endpoints update after node move');

      // cleanup
      deleteNode(a.id); deleteNode(b.id); deleteNode(dupId); deleteNode(n.id);
      state.idCounter = before; select(null); state.dirty = false;
      console.log('%cSelf-tests passed','color:green');
    }catch(err){ console.error('Self-tests failed:', err); }
  })();

  </script>
</body>
</html>

